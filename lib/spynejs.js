(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("ramda"), require("rxjs"));
	else if(typeof define === 'function' && define.amd)
		define("spyne", ["ramda", "rxjs"], factory);
	else if(typeof exports === 'object')
		exports["spyne"] = factory(require("ramda"), require("rxjs"));
	else
		root["spyne"] = factory(root["R"], root["Rx"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_ramda__, __WEBPACK_EXTERNAL_MODULE_rxjs__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/spyne/spyne.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/data.validation/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/data.validation/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright (c) 2013-2014 Quildreen Motta <quildreen@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = __webpack_require__(/*! ./validation */ \"./node_modules/data.validation/lib/validation.js\")\n\n//# sourceURL=webpack://spyne/./node_modules/data.validation/lib/index.js?");

/***/ }),

/***/ "./node_modules/data.validation/lib/validation.js":
/*!********************************************************!*\
  !*** ./node_modules/data.validation/lib/validation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright (c) 2013-2014 Quildreen Motta <quildreen@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module lib/validation\n */\nmodule.exports = Validation\n\n// -- Aliases ----------------------------------------------------------\nvar clone         = Object.create\nvar unimplemented = function(){ throw new Error('Not implemented.') }\nvar noop          = function(){ return this                         }\n\n\n// -- Implementation ---------------------------------------------------\n\n/**\n * The `Validation[α, β]` is a disjunction that's more appropriate for\n * validating inputs, or any use case where you want to aggregate failures. Not\n * only does the `Validation` provide a better terminology for working with\n * such cases (`Failure` and `Success` versus `Failure` and `Success`), it also\n * allows one to easily aggregate failures and successes as an Applicative\n * Functor.\n *\n * @class\n * @summary\n * Validation[α, β] <: Applicative[β]\n *                   , Functor[β]\n *                   , Show\n *                   , Eq\n */\nfunction Validation() { }\n\nFailure.prototype = clone(Validation.prototype)\nfunction Failure(a) {\n  this.value = a\n}\n\nSuccess.prototype = clone(Validation.prototype)\nfunction Success(a) {\n  this.value = a\n}\n\n// -- Constructors -----------------------------------------------------\n\n/**\n * Constructs a new `Validation[α, β]` structure holding a `Failure` value.\n *\n * @summary a → Validation[α, β]\n */\nValidation.Failure = function(a) {\n  return new Failure(a)\n}\nValidation.prototype.Failure = Validation.Failure\n\n/**\n * Constructs a new `Etiher[α, β]` structure holding a `Success` value.\n *\n * @summary β → Validation[α, β]\n */\nValidation.Success = function(a) {\n  return new Success(a)\n}\nValidation.prototype.Success = Validation.Success\n\n\n// -- Conversions ------------------------------------------------------\n\n/**\n * Constructs a new `Validation[α, β]` structure from a nullable type.\n *\n * Takes the `Failure` case if the value is `null` or `undefined`. Takes the\n * `Success` case otherwise.\n *\n * @summary α → Validation[α, α]\n */\nValidation.fromNullable = function(a) {\n  return a != null?       new Success(a)\n  :      /* otherwise */  new Failure(a)\n}\nValidation.prototype.fromNullable = Validation.fromNullable\n\n/**\n * Constructs a new `Either[α, β]` structure from a `Validation[α, β]` type.\n *\n * @summary Either[α, β] → Validation[α, β]\n */\nValidation.fromEither = function(a) {\n  return a.fold(Validation.Failure, Validation.Success)\n}\n\n\n// -- Predicates -------------------------------------------------------\n\n/**\n * True if the `Validation[α, β]` contains a `Failure` value.\n *\n * @summary Boolean\n */\nValidation.prototype.isFailure = false\nFailure.prototype.isFailure    = true\n\n/**\n * True if the `Validation[α, β]` contains a `Success` value.\n *\n * @summary Boolean\n */\nValidation.prototype.isSuccess = false\nSuccess.prototype.isSuccess    = true\n\n\n// -- Applicative ------------------------------------------------------\n\n/**\n * Creates a new `Validation[α, β]` instance holding the `Success` value `b`.\n *\n * `b` can be any value, including `null`, `undefined` or another\n * `Validation[α, β]` structure.\n *\n * @summary β → Validation[α, β]\n */\nValidation.of = function(a) {\n  return new Success(a)\n}\nValidation.prototype.of = Validation.of\n\n\n/**\n * Applies the function inside the `Success` case of the `Validation[α, β]` structure\n * to another applicative type.\n *\n * The `Validation[α, β]` should contain a function value, otherwise a `TypeError`\n * is thrown.\n *\n * @method\n * @summary (@Validation[α, β → γ], f:Applicative[_]) => f[β] → f[γ]\n */\nValidation.prototype.ap = unimplemented\n\nFailure.prototype.ap = function(b) {\n  return b.isFailure?     this.Failure(this.value.concat(b.value))\n  :      /* otherwise */  this\n}\n\nSuccess.prototype.ap = function(b) {\n  return b.isFailure?     b\n  :      /* otherwise */  b.map(this.value)\n}\n\n\n// -- Functor ----------------------------------------------------------\n\n/**\n * Transforms the `Success` value of the `Validation[α, β]` structure using a regular\n * unary function.\n *\n * @method\n * @summary (@Validation[α, β]) => (β → γ) → Validation[α, γ]\n */\nValidation.prototype.map = unimplemented\nFailure.prototype.map    = noop\n\nSuccess.prototype.map = function(f) {\n  return this.of(f(this.value))\n}\n\n\n// -- Show -------------------------------------------------------------\n\n/**\n * Returns a textual representation of the `Validation[α, β]` structure.\n *\n * @method\n * @summary (@Validation[α, β]) => Void → String\n */\nValidation.prototype.toString = unimplemented\n\nFailure.prototype.toString = function() {\n  return 'Validation.Failure(' + this.value + ')'\n}\n\nSuccess.prototype.toString = function() {\n  return 'Validation.Success(' + this.value + ')'\n}\n\n\n// -- Eq ---------------------------------------------------------------\n\n/**\n * Tests if an `Validation[α, β]` structure is equal to another `Validation[α, β]`\n * structure.\n *\n * @method\n * @summary (@Validation[α, β]) => Validation[α, β] → Boolean\n */\nValidation.prototype.isEqual = unimplemented\n\nFailure.prototype.isEqual = function(a) {\n  return a.isFailure && (a.value === this.value)\n}\n\nSuccess.prototype.isEqual = function(a) {\n  return a.isSuccess && (a.value === this.value)\n}\n\n\n// -- Extracting and recovering ----------------------------------------\n\n/**\n * Extracts the `Success` value out of the `Validation[α, β]` structure, if it\n * exists. Otherwise throws a `TypeError`.\n *\n * @method\n * @summary (@Validation[α, β]) => Void → β         :: partial, throws\n * @see {@link module:lib/validation~Validation#getOrElse} — A getter that can handle failures.\n * @see {@link module:lib/validation~Validation#merge} — The convergence of both values.\n * @throws {TypeError} if the structure has no `Success` value.\n */\nValidation.prototype.get = unimplemented\n\nFailure.prototype.get = function() {\n  throw new TypeError(\"Can't extract the value of a Failure(a).\")\n}\n\nSuccess.prototype.get = function() {\n  return this.value\n}\n\n\n/**\n * Extracts the `Success` value out of the `Validation[α, β]` structure. If the\n * structure doesn't have a `Success` value, returns the given default.\n *\n * @method\n * @summary (@Validation[α, β]) => β → β\n */\nValidation.prototype.getOrElse = unimplemented\n\nFailure.prototype.getOrElse = function(a) {\n  return a\n}\n\nSuccess.prototype.getOrElse = function(_) {\n  return this.value\n}\n\n\n/**\n * Transforms a `Failure` value into a new `Validation[α, β]` structure. Does nothing\n * if the structure contain a `Success` value.\n *\n * @method\n * @summary (@Validation[α, β]) => (α → Validation[γ, β]) → Validation[γ, β]\n */\nValidation.prototype.orElse = unimplemented\nSuccess.prototype.orElse    = noop\n\nFailure.prototype.orElse = function(f) {\n  return f(this.value)\n}\n\n\n/**\n * Returns the value of whichever side of the disjunction that is present.\n *\n * @summary (@Validation[α, α]) => Void → α\n */\nValidation.prototype.merge = function() {\n  return this.value\n}\n\n\n// -- Folds and Extended Transformations -------------------------------\n\n/**\n * Applies a function to each case in this data structure.\n *\n * @method\n * @summary (@Validation[α, β]) => (α → γ), (β → γ) → γ\n */\nValidation.prototype.fold = unimplemented\n\nFailure.prototype.fold = function(f, _) {\n  return f(this.value)\n}\n\nSuccess.prototype.fold = function(_, g) {\n  return g(this.value)\n}\n\n/**\n * Catamorphism.\n * \n * @method\n * @summary (@Validation[α, β]) => { Success: α → γ, Failure: α → γ } → γ\n */\nValidation.prototype.cata = unimplemented\n\nFailure.prototype.cata = function(pattern) {\n  return pattern.Failure(this.value)\n}\n\nSuccess.prototype.cata = function(pattern) {\n  return pattern.Success(this.value)\n}\n\n\n/**\n * Swaps the disjunction values.\n *\n * @method\n * @summary (@Validation[α, β]) => Void → Validation[β, α]\n */\nValidation.prototype.swap = unimplemented\n\nFailure.prototype.swap = function() {\n  return this.Success(this.value)\n}\n\nSuccess.prototype.swap = function() {\n  return this.Failure(this.value)\n}\n\n\n/**\n * Maps both sides of the disjunction.\n *\n * @method\n * @summary (@Validation[α, β]) => (α → γ), (β → δ) → Validation[γ, δ]\n */\nValidation.prototype.bimap = unimplemented\n\nFailure.prototype.bimap = function(f, _) {\n  return this.Failure(f(this.value))\n}\n\nSuccess.prototype.bimap = function(_, g) {\n  return this.Success(g(this.value))\n}\n\n\n/**\n * Maps the failure side of the disjunction.\n *\n * @method\n * @summary (@Validation[α, β]) => (α → γ) → Validation[γ, β]\n */\nValidation.prototype.failureMap = unimplemented\nSuccess.prototype.failureMap    = noop\n\nFailure.prototype.failureMap = function(f) {\n  return this.Failure(f(this.value))\n}\n\n/**\n * Maps the failure side of the disjunction.\n *\n * @method\n * @deprecated in favour of {@link module:lib/validation~Validation#failureMap}\n * @summary (@Validation[α, β]) => (α → γ) → Validation[γ, β]\n */\nValidation.prototype.leftMap = Validation.prototype.failureMap\nSuccess.prototype.leftMap    = Success.prototype.failureMap\nFailure.prototype.leftMap    = Failure.prototype.failureMap\n\n\n//# sourceURL=webpack://spyne/./node_modules/data.validation/lib/validation.js?");

/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n//# sourceURL=webpack://spyne/./node_modules/whatwg-fetch/fetch.js?");

/***/ }),

/***/ "./src/spyne/channels/channel-dom.js":
/*!*******************************************!*\
  !*** ./src/spyne/channels/channel-dom.js ***!
  \*******************************************/
/*! exports provided: ChannelDOM */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChannelDOM\", function() { return ChannelDOM; });\n/* harmony import */ var _channels_channels_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../channels/channels-base */ \"./src/spyne/channels/channels-base.js\");\n/* harmony import */ var _utils_frp_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/frp-tools */ \"./src/spyne/utils/frp-tools.js\");\n/* harmony import */ var _utils_channel_util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/channel-util-dom */ \"./src/spyne/utils/channel-util-dom.js\");\n\n\n\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\n\nclass ChannelDOM extends _channels_channels_base__WEBPACK_IMPORTED_MODULE_0__[\"ChannelsBase\"] {\n  constructor() {\n    super();\n    this.bindStaticMethods();\n    this.observer$ = new Rx.Subject();\n    this.props.name = 'DOM';\n  }\n\n  init() {\n    this.domChannelConfig = window.Spyne.config.channels.DOM;\n    this.currentScrollY = window.scrollY;\n    let obs$Arr = this.getActiveObservables();\n    let dom$ = Rx.Observable.merge(...obs$Arr);\n\n    dom$.subscribe(p => {\n      let {action, channelPayload, srcElement, event} = p;\n      this.sendStreamItem(action, channelPayload, srcElement, event);\n    });\n  }\n\n  static getScrollMapFn(event) {\n    let action = this.channelActions.CHANNEL_DOM_SCROLL_EVENT;\n    let scrollY = window.scrollY;\n    let scrollDistance = this.currentScrollY - scrollY;\n    let scrollDir = scrollDistance >= 0 ? 'up' : 'down';\n    this.currentScrollY = scrollY;\n    let channelPayload = {scrollY, scrollDistance, scrollDir};\n    let srcElement = event.srcElement;\n    return {action, channelPayload, srcElement, scrollDistance, event};\n  }\n\n  static getMouseWheelMapFn(event) {\n    let action = this.channelActions.CHANNEL_DOM_MOUSEWHEEL_EVENT;\n    let scrollDir = event.deltaY <= 0 ? 'up' : 'down';\n    let {deltaX, deltaY, deltaZ} = event;\n    let channelPayload = {scrollDir, deltaX, deltaY, deltaZ};\n    let srcElement = event.srcElement;\n    return {action, channelPayload, srcElement, event};\n  }\n\n  static getResizeMapFn(event) {\n    let action = this.channelActions.CHANNEL_DOM_RESIZE_EVENT;\n    let channelPayload = R.pick(\n      ['innerWidth', 'innerHeight', 'outerWidth', 'outerHeight'], window);\n    let srcElement = event.srcElement;\n    return {action, channelPayload, srcElement, event};\n  }\n\n  static getOrientationMapFn(event) {\n    let action = this.channelActions.CHANNEL_DOM_ORIENTATION_EVENT;\n    const orientationStr = '(orientation: portrait)';\n    let isPortraitBool = window.matchMedia(orientationStr).matches;\n    let channelPayload = R.pick(\n      ['innerWidth', 'innerHeight', 'outerWidth', 'outerHeight'], window);\n    channelPayload['orientation'] = isPortraitBool === true\n      ? 'portrait'\n      : 'landscape';\n    let srcElement = event.srcElement;\n    return {action, channelPayload, srcElement, event};\n  }\n\n  getMediaQueryMapFn(event) {\n    let action = this.channelActions.CHANNEL_DOM_MEDIA_QUERY_EVENT;\n    let channelPayload = R.pick(['matches', 'media', 'mediaQueryName'], event);\n    let srcElement = event.srcElement;\n    return {action, channelPayload, srcElement, event};\n  }\n\n  createMouseWheelObservable(config) {\n    const debounceTime = config.debounceMSTimeForScroll;\n\n    return _utils_channel_util_dom__WEBPACK_IMPORTED_MODULE_2__[\"ChannelUtilsDom\"].createDomObservableFromEvent('mousewheel',\n      ChannelDOM.getMouseWheelMapFn.bind(this)).debounceTime(debounceTime);\n  }\n\n  createScrollObservable(config) {\n    const skipWhenDirIsMissing = evt => evt.scrollDistance === 0;\n    const debounceTime = config.debounceMSTimeForScroll;\n    return _utils_channel_util_dom__WEBPACK_IMPORTED_MODULE_2__[\"ChannelUtilsDom\"].createDomObservableFromEvent('scroll',\n      ChannelDOM.getScrollMapFn.bind(this))\n      .debounceTime(debounceTime)\n      .skipWhile(skipWhenDirIsMissing);\n  }\n\n  createOrientationObservable(config) {\n    // console.log(\"add orientation\");orientationchange\n    return _utils_channel_util_dom__WEBPACK_IMPORTED_MODULE_2__[\"ChannelUtilsDom\"].createDomObservableFromEvent('orientationchange',\n      ChannelDOM.getOrientationMapFn.bind(this));\n  }\n\n  createResizeObservable(config) {\n    const debounceTime = config.debounceMSTimeForResize;\n    // console.log('resize this ', this);\n\n    return _utils_channel_util_dom__WEBPACK_IMPORTED_MODULE_2__[\"ChannelUtilsDom\"].createDomObservableFromEvent('resize',\n      ChannelDOM.getResizeMapFn.bind(this)).debounceTime(debounceTime);\n  }\n\n  getActiveObservables(config = this.domChannelConfig) {\n    let obs$Arr = [];\n\n    // CHECK TO ADD MEDIA QUERY OBSERVABLE\n    // ==========================================\n    config['listenForMediaQueries'] = Object(_utils_frp_tools__WEBPACK_IMPORTED_MODULE_1__[\"checkIfObjIsNotEmptyOrNil\"])(\n      config.mediqQueries);\n\n    // =========================================\n\n    // config.listenForResize = false;\n    // config.listenForMouseWheel = true;\n    // config.listenForScroll = false;\n    let methods = {\n      'listenForResize': this.createResizeObservable.bind(this),\n      'listenForOrientation': this.createOrientationObservable.bind(this),\n      'listenForScroll': this.createScrollObservable.bind(this),\n      'listenForMouseWheel': this.createMouseWheelObservable.bind(this)\n    };\n\n    const addObservableToArr = (method, key, i) => {\n      const addObsBool = config[key];\n      if (addObsBool) {\n        obs$Arr.push(method(config));\n      } else {\n\n      }\n    };\n\n    R.mapObjIndexed(addObservableToArr, methods);\n\n    // 'listenForMediaQueries' : this.getMediaQueryObservable.bind(this)\n    this.checkForMediaQueries(config.listenForMediaQueries);\n\n    return obs$Arr;\n  }\n\n  checkForMediaQueries(bool) {\n    const sendMQStream = p => {\n      let {action, channelPayload, srcElement, event} = p;\n      this.sendStreamItem(action, channelPayload, srcElement, event,\n        this.observer$);\n    };\n\n    if (bool === true) {\n      this.getMediaQueryObservable(this.domChannelConfig)\n        .subscribe(sendMQStream);\n    }\n  }\n\n  getMediaQueryObservable(config) {\n    let arr = this.createMergedObsFromObj(config);\n    return Rx.Observable.merge(...arr).map(this.getMediaQueryMapFn.bind(this));\n  }\n\n  getRegisteredActionsArr() {\n    return [\n      'CHANNEL_DOM_SCROLL_EVENT',\n      'CHANNEL_DOM_MOUSEWHEEL_EVENT',\n      'CHANNEL_DOM_MEDIA_QUERY_EVENT',\n      'CHANNEL_DOM_RESIZE_EVENT',\n      'CHANNEL_DOM_ORIENTATION_EVENT'\n    ];\n  }\n\n  bindStaticMethods() {\n    this.createMediaQueryHandler = _utils_channel_util_dom__WEBPACK_IMPORTED_MODULE_2__[\"ChannelUtilsDom\"].createMediaQueryHandler.bind(\n      this);\n    this.createMergedObsFromObj = _utils_channel_util_dom__WEBPACK_IMPORTED_MODULE_2__[\"ChannelUtilsDom\"].createMergedObsFromObj.bind(\n      this);\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/channels/channel-dom.js?");

/***/ }),

/***/ "./src/spyne/channels/channel-route.js":
/*!*********************************************!*\
  !*** ./src/spyne/channels/channel-route.js ***!
  \*********************************************/
/*! exports provided: ChannelRoute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChannelRoute\", function() { return ChannelRoute; });\n/* harmony import */ var _channels_channels_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../channels/channels-base */ \"./src/spyne/channels/channels-base.js\");\n/* harmony import */ var _utils_channel_util_urls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/channel-util-urls */ \"./src/spyne/utils/channel-util-urls.js\");\n/* harmony import */ var _utils_channel_util_route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/channel-util-route */ \"./src/spyne/utils/channel-util-route.js\");\n\n\n\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n\nclass ChannelRoute extends _channels_channels_base__WEBPACK_IMPORTED_MODULE_0__[\"ChannelsBase\"] {\n  constructor() {\n    super();\n    this.createChannelActionsObj();\n    this.props.name = 'ROUTE';\n    this.routeConfigJson = this.getRouteConfig();\n    this.bindStaticMethods();\n    this.navToStream$ = new Rx.BehaviorSubject();\n    this.observer$ = this.navToStream$.map(info => this.onMapNext(info));\n  }\n\n  init() {\n    this.initStream();\n  }\n\n  createChannelActionsObj() {\n    let arr = this.getRegisteredActionsArr();\n    const converter = str => R.objOf(str, str);\n    let obj = R.mergeAll(R.chain(converter, arr));\n    this.channelActions = obj;\n  }\n\n  getRegisteredActionsArr() {\n    return [\n      'CHANNEL_ROUTE_DEEPLINK_EVENT',\n      'CHANNEL_ROUTE_CHANGE_EVENT'\n    ];\n  }\n\n  getRouteConfig() {\n    const spyneConfig = window.Spyne.config;\n    let routeConfig = R.path(['channels', 'ROUTE'], spyneConfig);\n    if (routeConfig.type === 'query') {\n      routeConfig.isHash = false;\n    }\n\n    let arr = _utils_channel_util_route__WEBPACK_IMPORTED_MODULE_2__[\"RouteUtils\"].flattenConfigObject(routeConfig.routes);\n    routeConfig['paramsArr'] = arr;\n    return routeConfig;\n  }\n\n  initStream() {\n    this.firstLoadStream$ = new Rx.BehaviorSubject(\n      this.onIncomingDomEvent(undefined, this.routeConfigJson,\n        '' + 'CHANNEL_ROUTE_DEEPLINK_EVENT'));\n    _utils_channel_util_route__WEBPACK_IMPORTED_MODULE_2__[\"RouteUtils\"].createPopStateStream(this.onIncomingDomEvent.bind(this));\n\n    this.observer$ = Rx.Observable.merge(this.firstLoadStream$,\n      this.navToStream$);\n  }\n\n  onMapNext(data, firstLoaded = false) {\n    data['action'] = 'CHANNEL_ROUTE_CHANGE_EVENT';\n    return data;\n  }\n\n  static onIncomingDomEvent(evt, config = this.routeConfigJson, actn) {\n    let action = actn !== undefined\n      ? actn\n      : this.channelActions.CHANNEL_ROUTE_CHANGE_EVENT;\n    let payload = this.getDataFromString(config);\n    // console.log('route dom ',action, payload);\n    this.sendStreamItem(action, payload, undefined, undefined,\n      this.navToStream$);\n  }\n\n  onIncomingObserverableData(pl) {\n    let action = this.channelActions.CHANNEL_ROUTE_CHANGE_EVENT;\n    let payload = this.getDataFromParams(pl);\n    let srcElement = R.path(['observableData', 'srcElement'], pl);\n    let uiEvent = pl.observableEvent;\n    let changeLocationBool = !payload.isHidden;\n    this.sendRouteStream(payload, changeLocationBool);\n    this.sendStreamItem(action, payload, srcElement, uiEvent,\n      this.navToStream$);\n  }\n\n  sendRouteStream(payload, changeWindowLoc = true) {\n    if (changeWindowLoc === true) {\n      this.setWindowLocation(payload);\n    }\n  }\n\n  static getRouteState(str) {\n    return 'CHANNEL_ROUTE_CHANGE_EVENT';\n  }\n\n  static getIsDeepLinkBool() {\n    return this._routeCount === 0;\n  }\n\n  static getRouteCount() {\n    if (this._routeCount === undefined) {\n      this._routeCount = 0;\n      return this._routeCount;\n    }\n    this._routeCount += 1;\n    return this._routeCount;\n  }\n\n  static getExtraPayloadParams(config = this.routeConfigJson) {\n    let routeCount = this.getRouteCount();\n    let isDeepLink = this.getIsDeepLinkBool();\n    let isHash = config.isHash;\n    let isHidden = config.isHidden;\n    let routeType = config.type;\n    return {routeCount, isDeepLink, isHash, isHidden, routeType};\n  }\n\n  static getDataFromParams(pl, config = this.routeConfigJson) {\n    let params = R.path(['observableData', 'payload'], pl);\n\n    let routeStr = this.getRouteStrFromParams(params, config);\n\n    let dataFromStr = this.getDataFromLocationStr();\n    let {routedParam, routedParamsArr} = dataFromStr;\n\n    params = R.merge(dataFromStr.params, params);\n\n    let {routeCount, isDeepLink, isHash, isHidden, routeType} = this.getExtraPayloadParams(\n      config);\n    return {\n      isDeepLink,\n      routeCount,\n      routedParam,\n      routedParamsArr,\n      params,\n      routeStr,\n      isHash,\n      isHidden,\n      routeType\n    };\n  }\n\n  static getDataFromString(config = this.routeConfigJson, actn) {\n    const type = config.type;\n    const str = _utils_channel_util_urls__WEBPACK_IMPORTED_MODULE_1__[\"URLUtils\"].getLocationStrByType(type);\n    let {routedParamsArr, routedParam, params, routeStr} = ChannelRoute.getParamsFromRouteStr(\n      str, config, type);\n    let {routeCount, isDeepLink, isHash, routeType, isHidden} = this.getExtraPayloadParams(\n      config);\n\n    let obj = {\n      isDeepLink,\n      routeCount,\n      routedParam,\n      routedParamsArr,\n      params,\n      routeStr,\n      isHash,\n      isHidden,\n      routeType\n    };\n    return obj;\n  }\n\n  static getDataFromLocationStr(t = 'slash') {\n    const type = this.routeConfigJson !== undefined\n      ? this.routeConfigJson.type\n      : t;\n    const str = _utils_channel_util_urls__WEBPACK_IMPORTED_MODULE_1__[\"URLUtils\"].getLocationStrByType(type);\n    let {routedParamsArr, routedParam, params, routeStr} = this.getParamsFromRouteStr(\n      str, this.routeConfigJson, type);\n    const action = this.getRouteState();\n    return {routedParamsArr, routedParam, params, routeStr, action};\n  }\n\n  static getLocationData() {\n    const locationParamsArr = [\n      'href',\n      'origin',\n      'protocol',\n      'host',\n      'hostname',\n      'port',\n      'pathname',\n      'search',\n      'hash'];\n    return R.pickAll(locationParamsArr, window.location);\n  }\n\n  static getRouteStrFromParams(paramsData, routeConfig, t) {\n    const type = t !== undefined ? t : routeConfig.type;\n    return _utils_channel_util_urls__WEBPACK_IMPORTED_MODULE_1__[\"URLUtils\"].convertParamsToRoute(paramsData, routeConfig, type);\n  }\n\n  static getParamsFromRouteStr(str, routeConfig, t) {\n    const type = t !== undefined ? t : routeConfig.type;\n    return _utils_channel_util_urls__WEBPACK_IMPORTED_MODULE_1__[\"URLUtils\"].convertRouteToParams(str, routeConfig, type);\n  }\n\n  checkEmptyRouteStr(str, isHash = false) {\n    const isEmpty = R.isEmpty(str);\n    const pathNameIsEmptyBool = isEmpty === true && isHash === false;\n    const hashNameIsEmptyBool = isEmpty === true && isHash === true;\n    const hashNameBool = isEmpty === false && isHash === true;\n\n    console.log('ROUTE STR CHECK ', {str, isHash});\n    if (pathNameIsEmptyBool === true || hashNameIsEmptyBool === true) {\n      return '/';\n    } else if (hashNameBool === true) {\n      return R.concat('#', str);\n    }\n    return str;\n  }\n\n  setWindowLocation(channelPayload) {\n    let {isHash, routeStr} = channelPayload;\n    routeStr = this.checkEmptyRouteStr(routeStr, isHash);\n    if (isHash === true) {\n      // window.location.hash = routeStr;\n      console.log('ROUTE STR FOR HASH ', routeStr);\n      window.history.pushState({}, '', routeStr);\n    } else {\n      // routeStr =  R.when(R.isEmpty, R.always('/'))(routeStr);\n      const checkForSlash = R.when(\n        R.compose(R.complement(R.equals('/')), R.head), R.concat('/', R.__));\n      window.history.pushState({}, '', checkForSlash(routeStr));\n    }\n  }\n\n  getWindowLocation() {\n    return window.location.pathname; // pullHashAndSlashFromPath(window.location.hash);\n  }\n\n  bindStaticMethods() {\n    this.getIsDeepLinkBool = ChannelRoute.getIsDeepLinkBool.bind(this);\n    this.getDataFromLocationStr = ChannelRoute.getDataFromLocationStr.bind(\n      this);\n    this.onIncomingDomEvent = ChannelRoute.onIncomingDomEvent.bind(this);\n    this.getDataFromString = ChannelRoute.getDataFromString.bind(this);\n    this.getParamsFromRouteStr = ChannelRoute.getParamsFromRouteStr.bind(this);\n    this.getLocationData = ChannelRoute.getLocationData.bind(this);\n    this.getRouteState = ChannelRoute.getRouteState.bind(this);\n    this.getDataFromParams = ChannelRoute.getDataFromParams.bind(this);\n    this.getRouteCount = ChannelRoute.getRouteCount.bind(this);\n    this.getExtraPayloadParams = ChannelRoute.getExtraPayloadParams.bind(this);\n    const curriedGetRoute = R.curryN(3, ChannelRoute.getRouteStrFromParams);\n    this.getRouteStrFromParams = curriedGetRoute(R.__, this.routeConfigJson,\n      this.routeConfigJson.type);\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/channels/channel-route.js?");

/***/ }),

/***/ "./src/spyne/channels/channel-stream-item.js":
/*!***************************************************!*\
  !*** ./src/spyne/channels/channel-stream-item.js ***!
  \***************************************************/
/*! exports provided: ChannelStreamItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChannelStreamItem\", function() { return ChannelStreamItem; });\n\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n\nclass ChannelStreamItem {\n  constructor(channelName, action, channelPayload, srcElement, event) {\n    let channel = channelName;\n\n    let channelStreamItemObj = {channel, action, channelPayload, srcElement, event};\n\n    const channelActionsArr = window.Spyne.getChannelActions(channel);\n\n    ChannelStreamItem.validateAction(action, channel, channelActionsArr);\n\n    if (channel === 'ROUTE') {\n      channelStreamItemObj['location'] = ChannelStreamItem.getLocationData();\n    }\n\n    return channelStreamItemObj;\n  }\n\n  static validateAction(action, channel, arr) {\n    let isInArr = R.contains(action, arr);\n    if (isInArr === false && window.Spyne !== undefined) {\n      console.warn(`warning: Action: '${action}' is not registered within the ${channel} channel!`);\n    }\n    return isInArr;\n  }\n\n  static getLocationData() {\n    const locationParamsArr = [\n      'href',\n      'origin',\n      'protocol',\n      'host',\n      'hostname',\n      'port',\n      'pathname',\n      'search',\n      'hash'];\n    return R.pickAll(locationParamsArr, window.location);\n  }\n\n  static getStreamItem() {\n\n  }\n\n  static getMouseEventKeys() {\n    return ['altKey', 'bubbles', 'cancelBubble', 'cancelable', 'clientX', 'clientY', 'composed', 'ctrlKey', 'currentTarget', 'defaultPrevented', 'detail', 'eventPhase', 'fromElement', 'isTrusted', 'layerX', 'layerY', 'metaKey', 'movementX', 'movementY', 'offsetX', 'offsetY', 'pageX', 'pageY', 'path', 'relatedTarget', 'returnValue', 'screenX', 'screenY', 'shiftKey', 'sourceCapabilities', 'srcElement', 'target', 'timeStamp', 'toElement', 'type', 'view', 'which', 'x', 'y'];\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/channels/channel-stream-item.js?");

/***/ }),

/***/ "./src/spyne/channels/channel-ui.js":
/*!******************************************!*\
  !*** ./src/spyne/channels/channel-ui.js ***!
  \******************************************/
/*! exports provided: ChannelUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChannelUI\", function() { return ChannelUI; });\n/* harmony import */ var _channels_channels_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../channels/channels-base */ \"./src/spyne/channels/channels-base.js\");\n\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\n\nclass ChannelUI extends _channels_channels_base__WEBPACK_IMPORTED_MODULE_0__[\"ChannelsBase\"] {\n  constructor() {\n    super();\n    this.props.name = 'UI';\n    this.keyEventsLoaded = false;\n    this.keyCodeArr = [];\n    // this.addKeyEvent(13);\n  }\n\n  getRegisteredActionsArr() {\n    return [\n      'CHANNEL_UI_EVENT',\n      'CHANNEL_UI_BLUR_EVENT',\n      'CHANNEL_UI_CLICK_EVENT',\n      'CHANNEL_UI_DBLCLICK_EVENT',\n      'CHANNEL_UI_FOCUS_EVENT',\n      'CHANNEL_UI_FOCUSIN_EVENT',\n      'CHANNEL_UI_FOCUSOUT_EVENT',\n      'CHANNEL_UI_INPUT_EVENT',\n      'CHANNEL_UI_KEYDOWN_EVENT',\n      'CHANNEL_UI_KEYPRESS_EVENT',\n      'CHANNEL_UI_KEYUP_EVENT',\n      'CHANNEL_UI_MOUSEDOWN_EVENT',\n      'CHANNEL_UI_MOUSEENTER_EVENT',\n      'CHANNEL_UI_MOUSELEAVE_EVENT',\n      'CHANNEL_UI_MOUSEMOVE_EVENT',\n      'CHANNEL_UI_MOUSEOUT_EVENT',\n      'CHANNEL_UI_MOUSEOVER_EVENT',\n      'CHANNEL_UI_MOUSEUP_EVENT',\n      'CHANNEL_UI_SELECT_EVENT'\n    ];\n  }\n\n  loadKeyStream() {\n    let keyUps = Rx.Observable.fromEvent(document, 'keyup');\n    let filterKeys = e => this.keyCodeArr.indexOf(e.keyCode) >= 0;\n    this.keyPresses$ = keyUps.groupBy(e => e.keyCode)\n      .mergeAll()\n      .filter(filterKeys)\n      .repeat()\n      .subscribe(this.onKeyPressed.bind(this));\n  }\n\n  addKeyEvent(num) {\n    if (this.keyEventsLoaded === false) {\n      this.loadKeyStream();\n    }\n    this.keyEventsLoaded = true;\n    this.registerKey(num);\n  }\n\n  registerKey(c) {\n    this.keyCodeArr.push(c);\n  }\n\n  onKeyPressed(evt) {\n    console.log('key is ', evt);\n  }\n\n  onIncomingObservable(obj) {\n    let eqsName = R.equals(obj.name, this.props.name);\n    let dataObj = obsVal => ({observableData: obj.data, uiEvent: obsVal});\n    let onSuccess = (obj) => obj.observable.map(dataObj)\n      .subscribe(this.onUIEvent.bind(this));\n    let onError = () => {};\n    return eqsName === true ? onSuccess(obj) : onError();\n  }\n\n  getActionState(val) {\n    let mainAction = 'CHANNEL_UI';\n    return val.uiEvent.type !== undefined ? `${mainAction}_${String(\n      val.uiEvent.type).toUpperCase()}_EVENT` : mainAction;\n  }\n\n  onUIEvent(obs) {\n    obs['action'] = this.getActionState(obs);\n    const action = this.getActionState(obs);\n    const {payload, srcElement} = obs.observableData;\n    const event = obs.uiEvent;\n    this.sendStreamItem(action, payload, srcElement, event);\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/channels/channel-ui.js?");

/***/ }),

/***/ "./src/spyne/channels/channels-base-controller.js":
/*!********************************************************!*\
  !*** ./src/spyne/channels/channels-base-controller.js ***!
  \********************************************************/
/*! exports provided: ChannelsBaseController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChannelsBaseController\", function() { return ChannelsBaseController; });\n/* harmony import */ var _channel_route__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./channel-route */ \"./src/spyne/channels/channel-route.js\");\n/* harmony import */ var _channel_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./channel-ui */ \"./src/spyne/channels/channel-ui.js\");\n/* harmony import */ var _channel_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./channel-dom */ \"./src/spyne/channels/channel-dom.js\");\n/* harmony import */ var _utils_channel_config_validator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/channel-config-validator */ \"./src/spyne/utils/channel-config-validator.js\");\n// import {baseCoreMixins}    from '../utils/mixins/base-core-mixins';\n// import {BaseStreamsMixins} from '../utils/mixins/base-streams-mixins';\n\n\n\n\n\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\n\n// const R = require('ramda');\n\nclass ChannelsBaseController {\n  constructor(obs$) {\n    this.addMixins();\n    this.map = new Map();\n    // console.log('RX IS ', Rx.Subject);\n    this.map.set('DISPATCHER', new Rx.Subject());\n  }\n\n  init() {\n    this.createMainStreams();\n  }\n\n  createObserver(obj) {\n    // RIGHT NOW THIS CREATES THE DISPATCHER STREAM\n    Object(_utils_channel_config_validator__WEBPACK_IMPORTED_MODULE_3__[\"validate\"])(obj.validations, obj.init);\n    this.map.set(obj.init.name, obj.init.observable());\n  }\n\n  createMainStreams() {\n    this.routeStream = new _channel_route__WEBPACK_IMPORTED_MODULE_0__[\"ChannelRoute\"]();\n    this.map.set('ROUTE', this.routeStream);\n\n    this.uiStream = new _channel_ui__WEBPACK_IMPORTED_MODULE_1__[\"ChannelUI\"]();\n    this.map.set('UI', this.uiStream);\n\n    this.domStream = new _channel_dom__WEBPACK_IMPORTED_MODULE_2__[\"ChannelDOM\"]();\n    this.map.set('DOM', this.domStream);\n    this.routeStream.init();\n    this.domStream.init();\n  }\n\n  addKeyEvent(key) {\n    this.map.get('UI').addKeyEvent(key);\n  }\n\n  registerStream(name, val) {\n    this.map.set(name, val);\n  }\n\n  getChannelActions(str) {\n    return this.map.get(str).getRegisteredActionsArr();\n  }\n\n  getStream(name) {\n    if (this.map.get(name) === undefined) {\n      console.warn(\n        `Spyne Warning: The Channel named \"${name}\" does not appear to be registered!`);\n    } else {\n      return this.map.get(name);\n    }\n  }\n\n  addMixins() {\n    //  ==================================\n    // BASE CORE DECORATORS\n    //  ==================================\n    // let coreMixins =  baseCoreMixins();\n    //  ==================================\n    // BASE STREAMS DECORATORS\n    //  ==================================\n    // let streamsMixins = BaseStreamsMixins();\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/channels/channels-base-controller.js?");

/***/ }),

/***/ "./src/spyne/channels/channels-base-data.js":
/*!**************************************************!*\
  !*** ./src/spyne/channels/channels-base-data.js ***!
  \**************************************************/
/*! exports provided: ChannelsBaseData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChannelsBaseData\", function() { return ChannelsBaseData; });\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ \"rxjs\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _channels_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./channels-base */ \"./src/spyne/channels/channels-base.js\");\n/* harmony import */ var _channel_stream_item__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./channel-stream-item */ \"./src/spyne/channels/channel-stream-item.js\");\n/* harmony import */ var whatwg_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! whatwg-fetch */ \"./node_modules/whatwg-fetch/fetch.js\");\n/* harmony import */ var whatwg_fetch__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(whatwg_fetch__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n// const R = require('ramda');\n\nclass ChannelsBaseData extends _channels_base__WEBPACK_IMPORTED_MODULE_1__[\"ChannelsBase\"] {\n  constructor(props = {}) {\n    super(props);\n    this.props = props;\n    this.observer$ = new rxjs__WEBPACK_IMPORTED_MODULE_0___default.a.AsyncSubject();\n    this.fetchData();\n  }\n  get observer() {\n    return this.observer$;\n  }\n\n  getRegisteredActionsArr() {\n    return [\n      'CHANNEL_DATA_EVENT'\n    ];\n  }\n\n  fetchData() {\n    const mapFn = this.props.map !== undefined ? this.props.map : (p) => p;\n\n    const createChannelStreamItem = (payload) => {\n      let action = 'CHANNEL_DATA_EVENT';\n      return new _channel_stream_item__WEBPACK_IMPORTED_MODULE_2__[\"ChannelStreamItem\"](this.props.name, action, payload);\n    };\n\n    let response$ = rxjs__WEBPACK_IMPORTED_MODULE_0___default.a.Observable.fromPromise(window.fetch(this.props.dataUrl))\n      .flatMap(r => rxjs__WEBPACK_IMPORTED_MODULE_0___default.a.Observable.fromPromise(r.json()))\n      .map(mapFn)\n      .map(createChannelStreamItem)\n      .multicast(this.observer$);\n\n    response$.connect();\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/channels/channels-base-data.js?");

/***/ }),

/***/ "./src/spyne/channels/channels-base.js":
/*!*********************************************!*\
  !*** ./src/spyne/channels/channels-base.js ***!
  \*********************************************/
/*! exports provided: ChannelsBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChannelsBase\", function() { return ChannelsBase; });\n/* harmony import */ var _channels_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./channels-config */ \"./src/spyne/channels/channels-config.js\");\n/* harmony import */ var _channel_stream_item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./channel-stream-item */ \"./src/spyne/channels/channel-stream-item.js\");\n\n\n// import {baseCoreMixins}    from '../utils/mixins/base-core-mixins';\n// import {BaseStreamsMixins} from '../utils/mixins/base-streams-mixins';\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n\nclass ChannelsBase {\n  constructor(props = {}) {\n    this.addMixins();\n    this.getRegisteredActionsArr.bind(this);\n    this.createChannelActionsObj();\n    const defaultName = {name: 'observer'};\n    let observer$ = new Rx.Subject();\n    this.props = Object.assign({}, defaultName, props);\n    this.observer$ = this.props['observer'] = observer$;\n    this.streamsController = window.Spyne.channels;// getGlobalParam('streamsController');\n    let dispatcherStream$ = this.streamsController.getStream('DISPATCHER');\n    dispatcherStream$.subscribe((val) => this.onIncomingObservable(val));\n  }\n\n  setTrace(bool) {\n  }\n\n  createChannelActionsObj() {\n    let arr = this.getRegisteredActionsArr();\n    const converter = str => R.objOf(str, str);\n    let obj = R.mergeAll(R.chain(converter, arr));\n    this.channelActions = obj;\n  }\n\n  getRegisteredActionsArr() {\n    return [];\n  }\n\n  get observer() {\n    return this.observer$;\n  }\n\n  onIncomingObservable(obj) {\n    let eqsName = R.equals(obj.name, this.props.name);\n    let dataObj = obsVal => ({\n      observableData: obj.data,\n      observableEvent: obsVal\n    });\n    let onSuccess = (obj) => obj.observable.map(dataObj)\n      .subscribe(this.onIncomingObserverableData.bind(this));\n    let onError = () => {};\n    return eqsName === true ? onSuccess(obj) : onError();\n  }\n\n  onIncomingObserverableData(obj) {\n  }\n\n  sendStreamItem(action, payload, srcElement, event, obs$ = this.observer$) {\n    let channelStreamItem = new _channel_stream_item__WEBPACK_IMPORTED_MODULE_1__[\"ChannelStreamItem\"](this.props.name, action,\n      payload, srcElement, event);\n    obs$.next(Object.freeze(channelStreamItem));\n  }\n\n  getChannel(channel) {\n    let isValidChannel = c => Object(_channels_config__WEBPACK_IMPORTED_MODULE_0__[\"registeredStreamNames\"])().includes(c);\n    let error = c => console.warn(\n      `channel name ${c} is not within ${_channels_config__WEBPACK_IMPORTED_MODULE_0__[\"registeredStreamNames\"]}`);\n    let startSubscribe = (c) => this.streamsController.getStream(c).observer;\n    let fn = R.ifElse(isValidChannel, startSubscribe, error);\n    return fn(channel);\n  }\n\n  addMixins() {\n    //  ==================================\n    // BASE CORE DECORATORS\n    //  ==================================\n    // let coreMixins =  baseCoreMixins();\n    //  ==================================\n    // BASE STREAMS DECORATORS\n    //  ==================================\n    // let streamsMixins = BaseStreamsMixins();\n    // let testFunc = streamsMixins.testFunc;\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/channels/channels-base.js?");

/***/ }),

/***/ "./src/spyne/channels/channels-config.js":
/*!***********************************************!*\
  !*** ./src/spyne/channels/channels-config.js ***!
  \***********************************************/
/*! exports provided: stepDisposeValidations, stepUpdateValidations, stepValidations, uiValidations, routeValidations, lifestreamValidations, registeredStreamNames, StreamsConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stepDisposeValidations\", function() { return stepDisposeValidations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stepUpdateValidations\", function() { return stepUpdateValidations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stepValidations\", function() { return stepValidations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uiValidations\", function() { return uiValidations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"routeValidations\", function() { return routeValidations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lifestreamValidations\", function() { return lifestreamValidations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registeredStreamNames\", function() { return registeredStreamNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StreamsConfig\", function() { return StreamsConfig; });\n// import Spyne from '../spyne';\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\n\nlet registeredStreamNames = () => ({\n  includes:  () => window.Spyne !== undefined ? Array.from(window.Spyne.channels.map.keys()) : ['ROUTE', 'UI', 'DOM', 'DISPATCHER']\n\n});\n// getGlobalObj().channelsListArr;\nlet registeredSteps = ['LOAD', 'RENDER', 'MOUNT', 'UNMOUNT', 'DISPOSE', 'GARBAGE_COLLECT', 'UPDATE'];\nlet registeredLifeStreamTypes = ['parent', 'self', 'child', 'children', 'view'];\nlet registeredStreamTypes = ['Observable', 'BehaviorSubject', 'Subject', 'Observer', 'Subscriber', 'FromEventObservable'];\nlet registeredActions = ['subscribe', 'combineLatest'];\nlet getRxType = (obs) => obs().constructor.name;\n// let getObservableType = (obs) => obs.constructor.name;\nlet confirmObservable = (obs) => obs.subscribe !== undefined;\n// let pullMainRoute = (str) => str.replace(/^(\\/?)(.*)(\\/)(.*)/g, '$2');\n//  ===========================================================================\n// ALL VALIDATIONS ADD THE BASE VALIDATIONS THROUGH CONCATENATION\n//  ===========================================================================\nconst baseValidations = [\n  {\n    error: `need to match a valid name within ${registeredStreamTypes}`,\n    predicate: payload => registeredStreamNames().includes(payload.name)\n  },\n\n  {\n    error: `param 'observable' must contain a valid Rx.Observable`,\n    // predicate: payload => registeredStreamTypes.includes(getObservableType(payload.observable))\n    predicate: payload => confirmObservable(payload.observable)\n  },\n  {\n    error: 'param action must be a registered action',\n    predicate: payload => registeredActions.includes(payload.action)\n  }\n\n];\n//  ===========================================================================\n// THESE VALIDATIONS ARE CONCATENATED WHEN THE OBSERVABLE REFERS TO A VIEW\n//  ===========================================================================\nconst viewInfoValidations = [\n  {\n    error: 'needs cid number in srcElement',\n    predicate: R.compose(R.is(String), R.path(['data', 'srcElement', 'cid']))\n  },\n  {\n    error: 'needs a viewName in srcElement',\n    predicate: R.compose(R.is(String), R.path(['data', 'srcElement', 'viewName']))\n  }\n];\n\n//  ===========================================================================\n// NO SPECIFIC UI VALIDATIONS AT THIS TIME -- IT JUST ADD OTHERS\n//  ===========================================================================\nconst uiValidations = function() {\n  let uiValidations = [];\n  return uiValidations.concat(baseValidations).concat(viewInfoValidations);\n};\n//  ===========================================================================\n// NO SPECIFIC LIFESTREAM VALIDATIONS AT THIS TIME -- IT JUST ADD OTHERS\nlet lifeStreamValidations = [\n\n  {\n    error: `need to match a valid name within ${registeredStreamTypes}`,\n    predicate: payload => registeredStreamNames().includes(payload.name)\n  },\n\n  {\n    error: `needs one of the following step strings: ${registeredSteps}`,\n    predicate: payload => registeredSteps.includes(payload.STEP)\n  },\n  {\n    error: `type needs to one of the following: ${registeredLifeStreamTypes}`,\n    predicate: payload => registeredLifeStreamTypes.includes(payload.type)\n  },\n\n  {\n    error: 'viewId needs to be added ',\n    predicate: payload => payload.viewId !== undefined\n  }\n];\n\nconst stepValidations = function() {\n  let stepValidations = [];\n  return stepValidations.concat(lifeStreamValidations);\n};\n\nconst stepDisposeValidations = function() {\n  let stepUpdateValidations = [\n    {\n      error: 'DISPOSE STEP requires a disposeItem param in the data object',\n      predicate: payload => payload.STEP === 'DISPOSE' && payload.data.disposeItems !== undefined\n    }\n  ];\n  return stepUpdateValidations.concat(lifeStreamValidations);\n};\n\nconst stepUpdateValidations = function() {\n  let stepUpdateValidations = [\n    {\n      error: 'UPDATE STEP requires a data object ',\n      predicate: payload => payload.STEP === 'UPDATE' && payload.data !== undefined\n    }\n  ];\n  return stepUpdateValidations.concat(lifeStreamValidations);\n};\n//  ===========================================================================\n// lifestreamValidations\n//  ===========================================================================\nconst lifestreamValidations = function() {\n  return lifeStreamValidations.concat(baseValidations).concat(viewInfoValidations);\n};\n//  ===========================================================================\n// HERE IS THE ROUTE VALIDATIONS\n//  ===========================================================================\nconst routeValidations = function() {\n  let routeValidations = [\n    /*\n    *\n    {\n        error: `needs a valid route string within [${registeredRoutes}]`,\n        predicate: payload => registeredRoutes.includes(pullMainRoute(payload.data.navigateTo))\n    }\n    *\n    */\n\n  ];\n  return routeValidations.concat(baseValidations).concat(viewInfoValidations);\n};\n//  ===========================================================================\n/*\n* THE IDEA OF StreamsConfig IS TO COMPLETELY GENERATE ALL APP STREAMS USING THIS OBJECT\n* THIS HAS NOT BEEN IMPLEMENTED -- MAY BE ADDED IN A FUTURE VERSION\n*/\n//  ===========================================================================\nconst StreamsConfig = function() {\n  let streamValidations = [\n    {\n      error: `param 'name' must be of a registered type`,\n      predicate: payload => registeredStreamNames().includes(payload.name)\n    },\n    {\n      error: `param 'observable' must contain a valid Rx.Observable`,\n      predicate: payload => registeredStreamTypes.includes(getRxType(payload.observable))\n    },\n    {\n      error: 'param action must be a registered action',\n      predicate: payload => registeredActions.includes(payload.action)\n    }\n\n  ];\n\n  return {\n    streams: [\n      {\n        init: {\n          name: 'DISPATCHER',\n          observable: () => new Rx.Subject(),\n          action: 'subscribe'\n        },\n        structure: {\n          type: String,\n          observable: Rx.Observable || Rx.Subject,\n          action: String\n        },\n        validations: streamValidations\n      },\n      {\n        init: {\n          name: 'UBU',\n          observable: () => new Rx.Subject(),\n          action: 'subscribe'\n        },\n        structure: {\n          type: String,\n          observable: Rx.Observable || Rx.Subject,\n          action: String\n        },\n        validations: streamValidations\n      }\n    ]\n  };\n};\n\n\n\n//# sourceURL=webpack://spyne/./src/spyne/channels/channels-config.js?");

/***/ }),

/***/ "./src/spyne/channels/channels-payload.js":
/*!************************************************!*\
  !*** ./src/spyne/channels/channels-payload.js ***!
  \************************************************/
/*! exports provided: ChannelsPayload */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChannelsPayload\", function() { return ChannelsPayload; });\n/* harmony import */ var _channels_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./channels-config */ \"./src/spyne/channels/channels-config.js\");\n/* harmony import */ var _utils_channel_config_validator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/channel-config-validator */ \"./src/spyne/utils/channel-config-validator.js\");\n/* harmony import */ var _utils_gc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/gc */ \"./src/spyne/utils/gc.js\");\n/* harmony import */ var _utils_frp_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/frp-tools */ \"./src/spyne/utils/frp-tools.js\");\n// import {baseCoreMixins} from '../utils/mixins/base-core-mixins';\n\n\n\n// import {Right, Left, findInObj} from '../utils/frp-tools';\n\n// const Rx = require('rxjs');\n// const R = require('ramda');\nclass ChannelsPayload {\n  constructor(name, observable, data, action = 'subscribe', debug = false) {\n    this.addMixins();\n    this.options = {name, observable, data, action};\n    this.getValidationChecks(name);\n  }\n  getValidationChecks(n) {\n    let left  = e => console.warn(e);\n    let right = val => this.onRunValidations(val);\n    let obj = {\n      UI:         _channels_config__WEBPACK_IMPORTED_MODULE_0__[\"uiValidations\"],\n      ROUTE:      _channels_config__WEBPACK_IMPORTED_MODULE_0__[\"routeValidations\"],\n      LIFESTREAM: _channels_config__WEBPACK_IMPORTED_MODULE_0__[\"lifestreamValidations\"]\n    };\n    return Object(_utils_frp_tools__WEBPACK_IMPORTED_MODULE_3__[\"findInObj\"])(obj, n, 'payload Needs a Valid Stream Name!')\n      .fold(left, right);\n  }\n  onRunValidations(checks) {\n    Object(_utils_channel_config_validator__WEBPACK_IMPORTED_MODULE_1__[\"validate\"])(checks(), this.options).fold(\n      this.onError.bind(this),\n      this.onSuccess.bind(this));\n  }\n  onPayloadValidated(p) {\n    this.sendToDirectorStream(p);\n  }\n  sendToDirectorStream(payload) {\n    let streamsController = window.Spyne.channels;// getGlobalParam('streamsController');\n    let directorStream$ = streamsController.getStream('DISPATCHER');\n    directorStream$.next(payload);\n    this.gc();\n  }\n  onError(errors) {\n    console.warn('payload failed due to:\\n' + errors.map(e => '* ' + e).join('\\n'));\n    this.gc();\n  }\n  onSuccess(payload) {\n    this.onPayloadValidated(payload);\n  }\n  addMixins() {\n    //  ==================================\n    // BASE CORE MIXINS\n    //  ==================================\n    // let coreMixins = baseCoreMixins();\n    this.gc = _utils_gc__WEBPACK_IMPORTED_MODULE_2__[\"gc\"];\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/channels/channels-payload.js?");

/***/ }),

/***/ "./src/spyne/channels/lifestream-payload.js":
/*!**************************************************!*\
  !*** ./src/spyne/channels/lifestream-payload.js ***!
  \**************************************************/
/*! exports provided: LifestreamPayload */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LifestreamPayload\", function() { return LifestreamPayload; });\n/* harmony import */ var _channels_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./channels-config */ \"./src/spyne/channels/channels-config.js\");\n/* harmony import */ var _utils_channel_config_validator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/channel-config-validator */ \"./src/spyne/utils/channel-config-validator.js\");\n/* harmony import */ var _utils_gc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/gc */ \"./src/spyne/utils/gc.js\");\n/* harmony import */ var _utils_frp_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/frp-tools */ \"./src/spyne/utils/frp-tools.js\");\n// import {baseCoreMixins} from '../utils/mixins/base-core-mixins';\n\n\n\n// import {Right, Left, findInObj} from '../utils/frp-tools';\n\n// const Rx = require('rxjs');\n// const R = require('ramda');\nclass LifestreamPayload {\n  constructor(name, STEP, type, viewId, data = {}, debug = true) {\n    this.addMixins();\n    this.options = {name, STEP, type, viewId, data};\n    this.getValidationChecks(STEP);\n  }\n  get data() {\n    return this._data;\n  }\n  getValidationChecks(n) {\n    let left  = e => console.warn(e);\n    let right = val => this.onRunValidations(val);\n    let obj = {\n      LOAD:    _channels_config__WEBPACK_IMPORTED_MODULE_0__[\"stepValidations\"],\n      RENDER:  _channels_config__WEBPACK_IMPORTED_MODULE_0__[\"stepValidations\"],\n      MOUNT:   _channels_config__WEBPACK_IMPORTED_MODULE_0__[\"stepValidations\"],\n      DISPOSE: _channels_config__WEBPACK_IMPORTED_MODULE_0__[\"stepDisposeValidations\"],\n      UNMOUNT: _channels_config__WEBPACK_IMPORTED_MODULE_0__[\"stepValidations\"],\n      GARBAGE_COLLECT: _channels_config__WEBPACK_IMPORTED_MODULE_0__[\"stepValidations\"],\n      UPDATE:  _channels_config__WEBPACK_IMPORTED_MODULE_0__[\"stepUpdateValidations\"]\n    };\n    return Object(_utils_frp_tools__WEBPACK_IMPORTED_MODULE_3__[\"findInObj\"])(obj, n, 'lifestream payload Needs a Valid Stream Name!')\n      .fold(left, right);\n  }\n  onRunValidations(checks) {\n    Object(_utils_channel_config_validator__WEBPACK_IMPORTED_MODULE_1__[\"validate\"])(checks(), this.options).fold(\n      this.onError.bind(this),\n      this.onSuccess.bind(this));\n  }\n  onPayloadValidated(p) {\n    this._data = p;\n    return p;\n  }\n  onError(errors) {\n    console.error('payload failed due to:\\n' + errors.map(e => '* ' + e).join('\\n'));\n    this.gc();\n  }\n  onSuccess(payload) {\n    this.onPayloadValidated(payload);\n  }\n  addMixins() {\n    //  ==================================\n    // BASE CORE MIXINS\n    //  ==================================\n    // let coreMixins = baseCoreMixins();\n    this.gc = _utils_gc__WEBPACK_IMPORTED_MODULE_2__[\"gc\"];\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/channels/lifestream-payload.js?");

/***/ }),

/***/ "./src/spyne/spyne.js":
/*!****************************!*\
  !*** ./src/spyne/spyne.js ***!
  \****************************/
/*! exports provided: ViewToDomMediator, ChannelsBase, ChannelsBaseData, ChannelsBaseController, ChannelsPayload, ChannelStreamItem, DomItem, ViewStream, ViewStreamBroadcaster, Spyne */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Spyne\", function() { return Spyne; });\n/* harmony import */ var _channels_channels_base_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./channels/channels-base-controller */ \"./src/spyne/channels/channels-base-controller.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ChannelsBaseController\", function() { return _channels_channels_base_controller__WEBPACK_IMPORTED_MODULE_0__[\"ChannelsBaseController\"]; });\n\n/* harmony import */ var _views_dom_item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./views/dom-item */ \"./src/spyne/views/dom-item.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DomItem\", function() { return _views_dom_item__WEBPACK_IMPORTED_MODULE_1__[\"DomItem\"]; });\n\n/* harmony import */ var _views_view_to_dom_mediator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./views/view-to-dom-mediator */ \"./src/spyne/views/view-to-dom-mediator.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ViewToDomMediator\", function() { return _views_view_to_dom_mediator__WEBPACK_IMPORTED_MODULE_2__[\"ViewToDomMediator\"]; });\n\n/* harmony import */ var _views_view_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./views/view-stream */ \"./src/spyne/views/view-stream.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ViewStream\", function() { return _views_view_stream__WEBPACK_IMPORTED_MODULE_3__[\"ViewStream\"]; });\n\n/* harmony import */ var _views_view_stream_broadcaster__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./views/view-stream-broadcaster */ \"./src/spyne/views/view-stream-broadcaster.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ViewStreamBroadcaster\", function() { return _views_view_stream_broadcaster__WEBPACK_IMPORTED_MODULE_4__[\"ViewStreamBroadcaster\"]; });\n\n/* harmony import */ var _channels_channels_payload__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./channels/channels-payload */ \"./src/spyne/channels/channels-payload.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ChannelsPayload\", function() { return _channels_channels_payload__WEBPACK_IMPORTED_MODULE_5__[\"ChannelsPayload\"]; });\n\n/* harmony import */ var _channels_channels_base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./channels/channels-base */ \"./src/spyne/channels/channels-base.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ChannelsBase\", function() { return _channels_channels_base__WEBPACK_IMPORTED_MODULE_6__[\"ChannelsBase\"]; });\n\n/* harmony import */ var _channels_channels_base_data__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./channels/channels-base-data */ \"./src/spyne/channels/channels-base-data.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ChannelsBaseData\", function() { return _channels_channels_base_data__WEBPACK_IMPORTED_MODULE_7__[\"ChannelsBaseData\"]; });\n\n/* harmony import */ var _channels_channel_stream_item__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./channels/channel-stream-item */ \"./src/spyne/channels/channel-stream-item.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ChannelStreamItem\", function() { return _channels_channel_stream_item__WEBPACK_IMPORTED_MODULE_8__[\"ChannelStreamItem\"]; });\n\n/* harmony import */ var _utils_deep_merge__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/deep-merge */ \"./src/spyne/utils/deep-merge.js\");\n\n\n\n\n\n\n\n\n\n\n\nclass Spyne {\n  constructor(config = {}) {\n    this.channels = new _channels_channels_base_controller__WEBPACK_IMPORTED_MODULE_0__[\"ChannelsBaseController\"]();\n    this.VERSION = '0.7.0-BETA';\n    this.ViewStream = _views_view_stream__WEBPACK_IMPORTED_MODULE_3__[\"ViewStream\"];\n    this.BasicView = _views_view_to_dom_mediator__WEBPACK_IMPORTED_MODULE_2__[\"ViewToDomMediator\"];\n    this.DomItem = _views_dom_item__WEBPACK_IMPORTED_MODULE_1__[\"DomItem\"];\n    this.ViewStreamBroadcaster = _views_view_stream_broadcaster__WEBPACK_IMPORTED_MODULE_4__[\"ViewStreamBroadcaster\"];\n    this.ChannelsPayload = _channels_channels_payload__WEBPACK_IMPORTED_MODULE_5__[\"ChannelsPayload\"];\n    this.ChannelsBaseController = _channels_channels_base_controller__WEBPACK_IMPORTED_MODULE_0__[\"ChannelsBaseController\"];\n    this.ChannelsBase = _channels_channels_base__WEBPACK_IMPORTED_MODULE_6__[\"ChannelsBase\"];\n    window.Spyne = this;\n    let defaultConfig = {\n      channels: {\n        DOM: {\n          mediqQueries: {\n            'test': '(max-width: 500px)',\n            'newTest': '(max-width: 800px)'\n          },\n          listenForResize: true,\n          listenForOrientation: true,\n          listenForScroll: true,\n          listenForMouseWheel: false,\n          debounceMSTimeForResize: 200,\n          debounceMSTimeForScroll: 150\n        },\n\n        ROUTE: {\n          type: 'slash',\n          isHash: false,\n          isHidden: false,\n          routes: {\n            'route' : {\n              'keyword' : 'change'\n            }\n          }\n\n        }\n      }\n    };\n    if (config !== undefined) {\n      window.Spyne['config'] = Object(_utils_deep_merge__WEBPACK_IMPORTED_MODULE_9__[\"deepMerge\"])(defaultConfig, config);// Object.assign({}, defaultConfig, config);// config !== undefined ? config : defaultConfig;\n      // console.log(\"CONFIG IS \",{defaultConfig, config},window.Spyne.config)\n    }\n    this.getChannelActions = (str) => window.Spyne.channels.getChannelActions(str);\n    this.registerChannel = (str, val) => this.channels.registerStream(str, val);\n    this.registerDataChannel = (obs$) => this.channels.registerStream(obs$.props.name, obs$);\n    this.channels.init();\n\n    // window.Spyne.channels.init();\n  }\n\n  static getChannelActions(str) {\n    return window.Spyne.channels.getChannelActions(str);\n  }\n\n  static registerChannel(str, val) {\n    if (window.Spyne === undefined) {\n      console.warn('Spyne has not been initialized');\n    } else {\n      return window.Spyne.channels.registerStream(str, val);\n    }\n  }\n}\n\n// let Spyne = {ViewToDomMediator, ChannelsBase, ChannelsBaseController, ChannelsPayload, DomItem, ViewStream, ViewStreamBroadcaster, registerChannel};\nwindow['Spyne'] = Spyne;\n\n\n\n//# sourceURL=webpack://spyne/./src/spyne/spyne.js?");

/***/ }),

/***/ "./src/spyne/utils/channel-config-validator.js":
/*!*****************************************************!*\
  !*** ./src/spyne/utils/channel-config-validator.js ***!
  \*****************************************************/
/*! exports provided: validate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validate\", function() { return validate; });\n/* harmony import */ var data_validation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! data.validation */ \"./node_modules/data.validation/lib/index.js\");\n/* harmony import */ var data_validation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(data_validation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ramda__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ramda */ \"ramda\");\n/* harmony import */ var ramda__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ramda__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst success = data_validation__WEBPACK_IMPORTED_MODULE_0___default.a.Success;\nconst failure = data_validation__WEBPACK_IMPORTED_MODULE_0___default.a.Failure;\nconst validate = Object(ramda__WEBPACK_IMPORTED_MODULE_1__[\"curry\"])((validations, thing) => {\n  const initial =     success(Object(ramda__WEBPACK_IMPORTED_MODULE_1__[\"curryN\"])(Object(ramda__WEBPACK_IMPORTED_MODULE_1__[\"length\"])(validations), Object(ramda__WEBPACK_IMPORTED_MODULE_1__[\"always\"])(thing)));\n  const run = (acc, v) =>\n    acc.ap(v.predicate(thing) ? success(thing) : failure([v.error]));\n  return Object(ramda__WEBPACK_IMPORTED_MODULE_1__[\"reduce\"])(run, initial, validations);\n});\n\n\n\n//# sourceURL=webpack://spyne/./src/spyne/utils/channel-config-validator.js?");

/***/ }),

/***/ "./src/spyne/utils/channel-util-dom.js":
/*!*********************************************!*\
  !*** ./src/spyne/utils/channel-util-dom.js ***!
  \*********************************************/
/*! exports provided: ChannelUtilsDom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChannelUtilsDom\", function() { return ChannelUtilsDom; });\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n\nclass ChannelUtilsDom {\n  constructor() {\n    this.createDomObservableFromEvent = ChannelUtilsDom.createDomObservableFromEvent.bind(\n      this);\n  }\n\n  static createDomObservableFromEvent(eventName, mapFn, isPassive = true) {\n    let addHandler = handler => window.addEventListener(eventName, handler,\n      {passive: isPassive});\n    let removeHandler = () => { window[eventName] = () => {}; };\n    return Rx.Observable.fromEventPattern(addHandler, removeHandler).map(mapFn);\n  }\n\n  // MEDIA QUERIES\n  static createMediaQuery(str) {\n    const mq = window.matchMedia(str);\n    this.checkIfValidMediaQuery(mq, str);\n    return mq;\n  }\n\n  static checkIfValidMediaQuery(mq, str) {\n    const noSpaces = str => str.replace(/\\s+/gm, '');\n    const isValidBool = mq.constructor.name === 'MediaQueryList' && noSpaces(mq.media) === noSpaces(str);\n    const warnMsg = str => console.warn(`Spyne Warning: the following query string, \"${str}\", does not match \"${mq.media}\" and may not be a valid Media Query item!`);\n    if (isValidBool === false) {\n      warnMsg(str);\n    }\n    return isValidBool;\n  }\n\n  static createMediaQueryHandler(query, key) {\n    let keyFn = key => p => {\n      p['mediaQueryName'] = key;\n      return p;\n    };\n\n    let mapKey = keyFn(key);\n\n    let Handlers = (q) => ({\n      addHandler: (handler) => { q.onchange = handler; },\n      removeHandler: (handler) => { q.onchange = () => {}; }\n    });\n    let mediaQueryHandler = new Handlers(query);\n    return new Rx.Observable.fromEventPattern(\n      mediaQueryHandler.addHandler,\n      mediaQueryHandler.removeHandler)\n      .map(mapKey);\n  }\n\n  static createMergedObsFromObj(config) {\n    let mediaQueriesObj = config.mediqQueries;\n    let arr = [];\n\n    const loopQueries = (val, key, obj) => {\n      let mq = ChannelUtilsDom.createMediaQuery(val);\n      arr.push(ChannelUtilsDom.createMediaQueryHandler(mq, key));\n      // return arr;\n    };\n\n    R.mapObjIndexed(loopQueries, mediaQueriesObj);\n    // let obs$ = Rx.Observable.merge(...arr);\n    // console.log('arr is ',arr);\n    return arr;\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/utils/channel-util-dom.js?");

/***/ }),

/***/ "./src/spyne/utils/channel-util-route.js":
/*!***********************************************!*\
  !*** ./src/spyne/utils/channel-util-route.js ***!
  \***********************************************/
/*! exports provided: RouteUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouteUtils\", function() { return RouteUtils; });\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\n\nclass RouteUtils {\n  constructor() {\n    this.createPopStateStream = RouteUtils.createPopStateStream.bind(this);\n  }\n\n  static createPopStateStream(subscribeFn) {\n    let addHandler = function(handler) {\n      window.onpopstate = handler;\n    };\n    let removeHandler = function() {\n      window.onpopstate = function() {};\n    };\n    let popupObs$ = Rx.Observable.fromEventPattern(addHandler, removeHandler);\n\n    popupObs$.subscribe(subscribeFn);\n  }\n\n  static getLastArrVal(arr) {\n    const getLastParam = (a) => R.last(a) !== undefined ? R.last(a) : '';\n    return getLastParam(arr);\n  }\n\n  static getRouteArrData(routeArr, paramsArr) {\n    let routedParamsArr =  R.filter(R.contains(R.__, routeArr), paramsArr);\n    const routedParam = RouteUtils.getLastArrVal(routedParamsArr);\n    // console.log('arr and keyword ',{routedParamsArr, routedParam});\n    return {routedParamsArr, routedParam};\n  }\n\n  static flattenConfigObject(obj) {\n    const go = obj_ => R.chain(([k, v]) => {\n      if (Object.prototype.toString.call(v) === '[object Object]') {\n        return R.map(([k_, v_]) => [`${k}.${k_}`, v_], go(v));\n      } else {\n        return [[k, v]];\n      }\n    }, R.toPairs(obj_));\n\n    return R.values(R.fromPairs(go(obj)));\n  }\n\n  static getLocationData() {\n    const locationParamsArr = [\n      'href',\n      'origin',\n      'protocol',\n      'host',\n      'hostname',\n      'port',\n      'pathname',\n      'search',\n      'hash'];\n    return R.pickAll(locationParamsArr, window.location);\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/utils/channel-util-route.js?");

/***/ }),

/***/ "./src/spyne/utils/channel-util-urls.js":
/*!**********************************************!*\
  !*** ./src/spyne/utils/channel-util-urls.js ***!
  \**********************************************/
/*! exports provided: URLUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"URLUtils\", function() { return URLUtils; });\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n\nclass URLUtils {\n  constructor() {\n    this.checkIfObjIsNotEmptyOrNil = URLUtils.checkIfObjIsNotEmptyOrNil.bind(this);\n  }\n\n  static checkIfObjIsNotEmptyOrNil(obj) {\n    const isNotEmpty = R.compose(R.complement(R.isEmpty), R.head, R.values);\n    const isNotNil = R.compose(R.complement(R.isNil), R.head, R.values);\n    const isNotNilAndIsNotEmpty = R.allPass([isNotEmpty, isNotNil]);\n    return isNotNilAndIsNotEmpty(obj);\n  }\n\n  static checkIfParamValueMatchesRegex(paramValue, routeObj) {\n    const rejectParamKey = R.reject(R.equals('keyword'));\n    const keysArr = R.compose(rejectParamKey, R.keys);\n    const testForRegexMatch = str => R.test(new RegExp(str), paramValue);\n    const checker = R.compose(R.find(testForRegexMatch), keysArr);\n    const regexMatchStr = checker(routeObj);\n    if (R.is(String, regexMatchStr)) {\n      routeObj = R.assoc(paramValue, R.prop(regexMatchStr, routeObj), routeObj);\n    }\n    return routeObj;\n  }\n\n  static getLocationStrByType(t, isHash = false) {\n    const type = isHash === true ? 'hash' : t;\n\n    const typeMap = {\n      'slash': 'pathname',\n      'query': 'search',\n      'hash': 'hash'\n    };\n    const prop = typeMap[type];\n    let str  = R.prop(prop, window.location);\n    let checkForSlashAndHash = /^(\\/)?(#)?(\\/)?(.*)$/;\n    return str.replace(checkForSlashAndHash, '$4');\n  }\n\n  static createRouteArrayFromParams(data, route, t = 'slash', paramsFromLoc) {\n    let urlArr = [];\n    let loopThroughParam = (routeObj) => {\n      let urlObj = {};\n      let keyword = routeObj.keyword; // PARAM FORM SPYNE CONFIG\n      let paramValFromData = data[keyword] !== undefined ? data[keyword] : R.prop(keyword, paramsFromLoc); // PULL VALUE FOR THIS PARAM FROM DATA\n      const paramValType = typeof (routeObj[paramValFromData]);\n      // console.log({routeObj, paramValType, paramValFromData, keyword})\n\n      if (paramValType === 'string') {\n        paramValFromData = routeObj[paramValFromData];\n      } else if (paramValType === 'undefined') {\n        routeObj = this.checkIfParamValueMatchesRegex(paramValFromData, routeObj);\n      }\n\n      urlObj[keyword] = paramValFromData;\n\n      // console.log(\"URL OBJ \",urlObj);\n      if (this.checkIfObjIsNotEmptyOrNil(urlObj)) {\n        // console.log(\"FOUND \",{paramValFromData, paramValType, urlObj, routeObj});\n        urlArr.push(urlObj);\n      } else {\n        // console.log(\"NOT FOUND \",paramValFromData, paramValType, urlObj, routeObj);\n\n      }\n\n      const isObject = R.is(Object, routeObj);\n      const objectParamExists = R.has(paramValFromData, routeObj);\n      const objectContainsRoute = R.has('route', routeObj);\n      const recursivelyCallLoopBool = objectParamExists && isObject;\n      // console.log(\"CHECKS \", {isObject, objectParamExists, objectContainsRoute, recursivelyCallLoopBool})\n      if (recursivelyCallLoopBool === true) {\n        let newObj = routeObj[paramValFromData];\n        // console.log(\"NEW OBJ \",{paramValFromData, routeObj, newObj});\n        if (R.has('route', newObj)) {\n          loopThroughParam(newObj.route);\n        }\n      } else if (objectContainsRoute === true && paramValFromData !== undefined) {\n        loopThroughParam(routeObj.route);\n      }\n    };\n\n    loopThroughParam(route);\n\n    return urlArr;\n  }\n\n  static createSlashString(arr) {\n    const arrClear = R.reject(R.isNil);\n    const notUndefined = R.when(R.complement(R.isNil, R.__), R.join('/'));\n\n    const joiner = R.compose(notUndefined, arrClear, R.flatten,\n      R.map(R.values));\n\n    return joiner(arr);\n  }\n\n  static createQueryString(arr) {\n    const arrClear = R.reject(R.isNil);\n\n    const isNotNilAndIsNotEmpty = this.checkIfObjIsNotEmptyOrNil;\n\n    const createPair = R.compose(\n      R.join('='),\n      R.flatten,\n      R.toPairs);\n\n    const checkPair = R.ifElse(\n      isNotNilAndIsNotEmpty,\n      createPair,\n      R.always(undefined)\n    );\n\n    const mapArrayOfPairs = R.map(checkPair);\n\n    const checkIfStrIsEmpty = R.when(\n      R.complement(R.isEmpty),\n      R.concat('?'));\n\n    const createQs = R.compose(\n      checkIfStrIsEmpty,\n      R.join('&'),\n      arrClear,\n      mapArrayOfPairs);\n\n    return createQs(arr);\n  }\n\n  static convertParamsToRoute(data, r = window.Spyne.config.channels.ROUTE, t, locStr) {\n    const urlType = t !== undefined ? t : r.type;\n    const isHash = r.isHash;\n    let route = r.routes.route;\n    let locationStr = locStr !== undefined ? locStr : this.getLocationStrByType(urlType, isHash);\n    let paramsFromCurrentLocation = this.convertRouteToParams(locationStr, r, urlType).params;\n\n    let urlArr = this.createRouteArrayFromParams(data, route, urlType, paramsFromCurrentLocation);\n    // THIS CREATES A QUERY PATH STR\n    if (urlType === 'query') {\n      return this.createQueryString(urlArr);\n    }\n\n    // THIS CREATES A SLASH PATH STR\n    return this.createSlashString(urlArr);\n  }\n\n  static checkIfValueShouldMapToParam(obj, str) {\n    let invertedObj = R.invert(obj);\n\n    let checkIfValMapsToParam = R.compose(R.is(String), R.head, R.defaultTo([]),\n      R.prop(str));\n    let getParam = R.compose(R.head, R.prop(str));\n\n    let strCheck = R.ifElse(\n      checkIfValMapsToParam,\n      getParam,\n      R.always(str)\n    );\n\n    return strCheck(invertedObj);\n  }\n\n  static createArrFromSlashStr(str) {\n    const slashRe = /^([/])?(.*)$/;\n    return str.replace(slashRe, '$2').split('/');\n  }\n\n  static convertSlashRouteStrToParamsObj(topLevelRoute, str) {\n    const routeStr = str;\n    let valuesArr = this.createArrFromSlashStr(str);\n    let routedParamsArr = [];\n    let routedValuesArr = [];\n    let latestObj = topLevelRoute;\n    let createParamsFromStr = (total, currentValue) => {\n      let routeValueStr = this.checkIfValueShouldMapToParam(latestObj, currentValue);\n\n      latestObj = this.checkIfParamValueMatchesRegex(currentValue, latestObj);\n\n      if (latestObj !== undefined) {\n        routedParamsArr.push(latestObj.keyword);\n        routedValuesArr.push(routeValueStr);\n      }\n      let strPath = [currentValue, 'route'];\n      let routeParamPath = ['route'];\n      let objectFromStr = R.path(strPath, latestObj);\n      let objectFromRouteParam = R.path(routeParamPath, latestObj);\n\n      if (objectFromStr !== undefined) {\n        latestObj = objectFromStr;\n      } else if (objectFromRouteParam !== undefined) {\n        latestObj = objectFromRouteParam;\n      }\n    };\n\n    R.reduce(createParamsFromStr, 0, valuesArr);\n    let params = R.zipObj(routedParamsArr, routedValuesArr);\n    const routedParam = this.getLastArrVal(routedParamsArr);\n    return {routedParamsArr, routedParam, params, routeStr};\n  }\n\n  static getLastArrVal(arr) {\n    const getLastParam = (a) => R.last(a) !== undefined ? R.last(a) : '';\n    return getLastParam(arr);\n  }\n\n  static createDefaultParamFromEmptyStr(topLevelRoute, str) {\n    let obj = {};\n    let keyword = topLevelRoute.keyword;\n    obj[keyword] = this.checkIfValueShouldMapToParam(topLevelRoute, str);\n    return obj;\n  }\n\n  static convertQueryStrToParams(topLevelRoute, str) {\n    const queryRe = /^([?])?(.*)$/;\n    const routeStr = str;\n    let strArr = str.replace(queryRe, '$2');\n    let convertToParams = R.compose(R.map(R.split('=')), R.split('&'));\n    let paramsArr = convertToParams(strArr);\n    let params = R.fromPairs(paramsArr);\n\n    let routedParamsArr = R.map(R.head, paramsArr);\n\n    if (R.isEmpty(str) === true) {\n      params = this.createDefaultParamFromEmptyStr(topLevelRoute, str);\n      routedParamsArr = R.keys(params);\n    }\n    let routedParam = this.getLastArrVal(routedParamsArr);\n\n    return {routedParamsArr, routedParam, params, routeStr};\n  }\n\n  static convertRouteToParams(str, routeConfig, t) {\n    if (routeConfig === undefined) {\n      return {};\n    }\n    const type = t !== undefined ? t : routeConfig.type;\n    let topLevelRoute = routeConfig.routes.route;\n\n    if (type === 'query') {\n      return this.convertQueryStrToParams(topLevelRoute, str);\n    }\n\n    return this.convertSlashRouteStrToParamsObj(topLevelRoute, str);\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/utils/channel-util-urls.js?");

/***/ }),

/***/ "./src/spyne/utils/deep-merge.js":
/*!***************************************!*\
  !*** ./src/spyne/utils/deep-merge.js ***!
  \***************************************/
/*! exports provided: deepMerge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deepMerge\", function() { return deepMerge; });\nfunction isMergeableObject(val) {\n  let nonNullObject = val && typeof val === 'object';\n  return nonNullObject && Object.prototype.toString.call(val) !== '[object RegExp]' && Object.prototype.toString.call(val) !== '[object Date]';\n}\n\nfunction emptyTarget(val) {\n  return Array.isArray(val) ? [] : {};\n}\n\nfunction cloneIfNecessary(value, optionsArgument) {\n  let clone = optionsArgument && optionsArgument.clone === true;\n  return (clone && isMergeableObject(value)) ? deepMerge(emptyTarget(value),\n    value, optionsArgument) : value;\n}\n\nfunction defaultArrayMerge(target, source, optionsArgument) {\n  let destination = target.slice();\n  source.forEach(function(e, i) {\n    if (typeof destination[i] === 'undefined') {\n      destination[i] = cloneIfNecessary(e, optionsArgument);\n    } else if (isMergeableObject(e)) {\n      destination[i] = deepMerge(target[i], e, optionsArgument);\n    } else if (target.indexOf(e) === -1) {\n      destination.push(cloneIfNecessary(e, optionsArgument));\n    }\n  });\n  return destination;\n}\n\nfunction mergeObject(target, source, optionsArgument) {\n  let destination = {};\n  if (isMergeableObject(target)) {\n    Object.keys(target).forEach(function(key) {\n      destination[key] = cloneIfNecessary(target[key], optionsArgument);\n    });\n  }\n  Object.keys(source).forEach(function(key) {\n    if (!isMergeableObject(source[key]) || !target[key]) {\n      destination[key] = cloneIfNecessary(source[key], optionsArgument);\n    } else {\n      destination[key] = deepMerge(target[key], source[key], optionsArgument);\n    }\n  });\n  return destination;\n}\n\nfunction deepMerge(target, source, optionsArgument) {\n  let array = Array.isArray(source);\n  let options = optionsArgument || {arrayMerge: defaultArrayMerge};\n  let arrayMerge = options.arrayMerge || defaultArrayMerge;\n\n  if (array) {\n    return Array.isArray(target)\n      ? arrayMerge(target, source, optionsArgument)\n      : cloneIfNecessary(source, optionsArgument);\n  } else {\n    return mergeObject(target, source, optionsArgument);\n  }\n}\n\ndeepMerge.all = function deepmergeAll(array, optionsArgument) {\n  if (!Array.isArray(array) || array.length < 2) {\n    throw new Error(\n      'first argument should be an array with at least two elements');\n  }\n\n  // we are sure there are at least 2 values, so it is safe to have no initial value\n  return array.reduce(function(prev, next) {\n    return deepMerge(prev, next, optionsArgument);\n  });\n};\n\n\n\n\n//# sourceURL=webpack://spyne/./src/spyne/utils/deep-merge.js?");

/***/ }),

/***/ "./src/spyne/utils/frp-tools.js":
/*!**************************************!*\
  !*** ./src/spyne/utils/frp-tools.js ***!
  \**************************************/
/*! exports provided: getAllMethodNames, findStrOrRegexMatchStr, findStrFromRegexArr, checkIfObjIsNotEmptyOrNil, isIOS, pullRouteInfo, pullTranslateYFromHeader, pullSlashFromPath, pullHashAndSlashFromPath, closest, pullTranslateY, pullTranslateX, pullMainRoute, pullParams, right, left, fromNullable, findInObj, ifNilThenUpdate, removeSlashes, subscribeFn, convertDomStringMapToObj */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAllMethodNames\", function() { return getAllMethodNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findStrOrRegexMatchStr\", function() { return findStrOrRegexMatchStr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findStrFromRegexArr\", function() { return findStrFromRegexArr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkIfObjIsNotEmptyOrNil\", function() { return checkIfObjIsNotEmptyOrNil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIOS\", function() { return isIOS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pullRouteInfo\", function() { return pullRouteInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pullTranslateYFromHeader\", function() { return pullTranslateYFromHeader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pullSlashFromPath\", function() { return pullSlashFromPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pullHashAndSlashFromPath\", function() { return pullHashAndSlashFromPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closest\", function() { return closest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pullTranslateY\", function() { return pullTranslateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pullTranslateX\", function() { return pullTranslateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pullMainRoute\", function() { return pullMainRoute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pullParams\", function() { return pullParams; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"right\", function() { return right; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"left\", function() { return left; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromNullable\", function() { return fromNullable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findInObj\", function() { return findInObj; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ifNilThenUpdate\", function() { return ifNilThenUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeSlashes\", function() { return removeSlashes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subscribeFn\", function() { return subscribeFn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertDomStringMapToObj\", function() { return convertDomStringMapToObj; });\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\nconst isIOS = () => {\n  let userAgent = window.navigator.userAgent.toLowerCase();\n  // let safari = /safari/.test(userAgent);\n  let ios = /iphone|ipod|ipad/.test(userAgent);\n  return ios === true;\n};\n\nconst findStrFromRegexArr = (obj, str) => {\n  if (obj[str] !== undefined) {\n    return str;\n  }\n  const checkIfMatch = s => R.test(new RegExp(s), str);\n  const checkStrMatch = R.contains(str);\n  const checkIfRegExMatch = R.compose(R.contains(true), R.map(checkIfMatch));\n  const runMatchChecks = R.cond([\n    [checkStrMatch, () => str],\n    [checkIfRegExMatch, () => str],\n    [R.T, () => undefined]\n  ]);\n  return runMatchChecks(obj);\n};\n\nconst findStrOrRegexMatchStr = (obj, str) => {\n  if (obj[str] !== undefined) {\n    return str;\n  }\n  const createRe = s => new RegExp(s);\n  let checkerIfRegexMatchExists = R.compose(R.head, R.filter(R.compose(R.test(R.__, str), createRe)));\n  return checkerIfRegexMatchExists(R.keys(obj));\n};\n\nconst closest = (array, num) => {\n  let i = 0;\n  let minDiff = 1000;\n  let ans;\n  for (i in array) {\n    let m = Math.abs(num - array[i]);\n    if (m < minDiff) {\n      minDiff = m;\n      ans = array[i];\n    }\n  }\n  return ans;\n};\n\nconst convertDomStringMapToObj = (domMap) => {\n  let obj = {};\n  for (let d in domMap) {\n    obj[d] = domMap[d];\n  }\n  return obj;\n};\n\n// const passPageData = R.pick(['params', 'routeId', 'data'], R.__);\n\nconst subscribeFn = {\n  next:     x => console.log(`next      ${x}`),\n  error:    x => console.log(`error     ${x}`),\n  complete: x => console.log(`complete  ${x}`)\n};\n\nconst right = x => ({\n  map: f => right(f(x)),\n  fold: (f, g) => g(x),\n  inspect: () => `right(${x})`\n\n});\n\nconst ifNilThenUpdate = (val, newVal) => {\n  let isNil = R.isNil(val);\n  return isNil ? newVal : val;\n};\n\nconst left = x => ({\n  map: f => left(x),\n  fold: (f, g) => f(x),\n  inspect: () => `left(${x})`\n});\n\nconst checkIfObjIsNotEmptyOrNil = (obj) => {\n  const isNotEmpty = R.compose(R.complement(R.isEmpty), R.head, R.values);\n  const isNotNil = R.compose(R.complement(R.isNil), R.head, R.values);\n  const isNotNilAndIsNotEmpty = R.allPass([isNotEmpty, isNotNil]);\n  return isNotNilAndIsNotEmpty(obj);\n};\n\nconst fromNullable = x => x !== null ? right(x) : left(null);\n\nconst findInObj = (obj, val, error = null) => {\n  const found = obj[val];\n  return found ? right(found) : left(error);\n};\nconst pullRouteInfo = () => {\n  let str = pullHashAndSlashFromPath(window.location.hash);\n  let routeId = pullMainRoute(str);\n  let params = pullParams(str);\n  return {routeId, params};\n};\n\nconst getAllMethodNames = (_this = undefined, omittedMethods = []) => {\n  const getPropNamesArr = (obj = undefined, omittedMethods = []) => {\n    return Object.getOwnPropertyNames(obj);\n  };\n  // Filter Methods\n  let baseClassMethodsArr = ['length', 'name', 'prototype', 'constructor'];\n  omittedMethods = R.concat(baseClassMethodsArr, omittedMethods);\n  let omitPropsFromArr = R.compose(R.without(omittedMethods), R.uniq);\n\n  // PULL OUT METHOD NAMES\n  let methods = omitPropsFromArr(Object.getOwnPropertyNames(_this.constructor.prototype));\n  let staticMethods = omitPropsFromArr(getPropNamesArr(_this.constructor));\n  let allMethods = R.concat(methods, staticMethods);\n\n  return {methods, staticMethods, allMethods};\n  // return 'fn';\n};\n\n// ROUTE REGEX EXPRESSIONS\nconst removeSlashes = str => str.replace(/^(\\/)(.*)/g, '$2');\nconst routeRE = /^(\\/?)(\\w*)(\\/?)(.*)/g;\nconst pullHashAndSlashFromPath = (str) => str.replace(/^(#\\/?)(.*)/, '$2');\nconst pullSlashFromPath = (str) => str.replace(/^(\\/?)(.*)/, '$2');\nconst pullMainRoute = (str) => str.replace(routeRE, '$2');\nconst pullParams =    (str) => str.replace(routeRE, '$4');\nconst pullTranslateX = str => str.replace(/^(matrix)(.*\\d*,)(.*\\d*,)(.*\\d*,)(.*\\d*,)(.*\\d*)(,.*)/, '$6');\nconst pullTranslateY = str => str.replace(/^(matrix)(.*\\d*,)(.*\\d*,)(.*\\d*,)(.*\\d*,)(.*\\d*,)(.*\\d)(.*)/, '$7');\nconst pullTranslateYFromHeader = str => str.replace(/^(transform: matrix)(.*\\d*,)(.*\\d*,)(.*\\d*,)(.*\\d*,)(.*\\d*)(\\).*;)/, '$6');\n\n\n\n//# sourceURL=webpack://spyne/./src/spyne/utils/frp-tools.js?");

/***/ }),

/***/ "./src/spyne/utils/gc.js":
/*!*******************************!*\
  !*** ./src/spyne/utils/gc.js ***!
  \*******************************/
/*! exports provided: gc */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gc\", function() { return gc; });\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\nfunction gc() {\n  let cleanup = () => {\n    let loopM = m => void 0;\n    R.forEach(loopM, this);\n  };\n  setTimeout(cleanup, 1);\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/utils/gc.js?");

/***/ }),

/***/ "./src/spyne/utils/mixins/base-core-mixins.js":
/*!****************************************************!*\
  !*** ./src/spyne/utils/mixins/base-core-mixins.js ***!
  \****************************************************/
/*! exports provided: baseCoreMixins */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"baseCoreMixins\", function() { return baseCoreMixins; });\nfunction baseCoreMixins() {\n  return {\n    createpropsMap: function() {\n      let wm = new WeakMap();\n      let objKey = {cid: this.props.cid};\n      wm.set(objKey, this.props);\n      return {\n        key: objKey,\n        weakMap: wm\n      };\n    },\n    gc: function() {\n      for (let m in this) {\n        delete this[m];\n      }\n      delete this;\n    },\n    createId: function() {\n      let num = Math.floor(Math.random(10000000) * 10000000);\n      return `cid-${num}`;\n    },\n    setTraceFunc: function(debug) {\n      return debug === true ? console.log : () => {\n      };\n    }\n  };\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/utils/mixins/base-core-mixins.js?");

/***/ }),

/***/ "./src/spyne/utils/mixins/base-streams-mixins.js":
/*!*******************************************************!*\
  !*** ./src/spyne/utils/mixins/base-streams-mixins.js ***!
  \*******************************************************/
/*! exports provided: baseStreamsMixins */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"baseStreamsMixins\", function() { return baseStreamsMixins; });\n/* harmony import */ var _channels_channels_payload__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../channels/channels-payload */ \"./src/spyne/channels/channels-payload.js\");\n/* harmony import */ var _channels_lifestream_payload__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../channels/lifestream-payload */ \"./src/spyne/channels/lifestream-payload.js\");\n\n\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\n\nfunction baseStreamsMixins() {\n  return {\n    testFunc: function(str) {\n      console.log('stream mixin is ', str);\n    },\n    sendRoutePayload: function(obs, data) {\n      return new _channels_channels_payload__WEBPACK_IMPORTED_MODULE_0__[\"ChannelsPayload\"]('ROUTE', obs, data, 'subscribe');\n    },\n    sendUIPayload: function(obs, data) {\n      return new _channels_channels_payload__WEBPACK_IMPORTED_MODULE_0__[\"ChannelsPayload\"]('UI', obs, data, 'subscribe');\n    },\n    sendChannelPayload: function(channelName, payload) {\n      const getProp = str => R.prop(str, this.props);\n      const channel = channelName;\n      let srcElement = {\n        cid: getProp('cid'),\n        el: getProp('el'),\n        viewName: getProp('name')\n      };\n      let data = {\n        payload, channel, srcElement\n      };\n\n      return new _channels_channels_payload__WEBPACK_IMPORTED_MODULE_0__[\"ChannelsPayload\"](channelName, new Rx.Observable.of(''), data,\n        'subscribe');\n    },\n    sendLifeStreamPayload: function(obs, data) {\n      return new _channels_channels_payload__WEBPACK_IMPORTED_MODULE_0__[\"ChannelsPayload\"]('LIFESTREAM', obs, data, 'subscribe');\n    },\n\n    createLifeStreamPayload: function(STEP, data = {}, type = 'parent') {\n      let viewId = `${this.props.name}: ${this.props.cid}`;\n      return new _channels_lifestream_payload__WEBPACK_IMPORTED_MODULE_1__[\"LifestreamPayload\"]('LIFESTREAM', STEP, type, viewId, data).data;\n    }\n  };\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/utils/mixins/base-streams-mixins.js?");

/***/ }),

/***/ "./src/spyne/utils/viewstream-animations.js":
/*!**************************************************!*\
  !*** ./src/spyne/utils/viewstream-animations.js ***!
  \**************************************************/
/*! exports provided: fadein, fadeout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadein\", function() { return fadein; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadeout\", function() { return fadeout; });\nlet createFaderInlineText = (isInBool = false, t = 1, e = 'ease', startZeroBool = false) => {\n  let initOpacityZero = startZeroBool === true ? 'opacity:0;' : '';\n  let opacity = isInBool === true ? 1 : 0;\n  return `${initOpacityZero}transition: opacity ${t}s ${e}; opacity: ${opacity};`;\n};\nfunction fadein(el, t) {\n  let currentOpacity = window.getComputedStyle(el).opacity * 1;\n  let startAtZero = currentOpacity === 1;\n  let inlineCss = createFaderInlineText(true, t, 'ease', startAtZero);\n  el.style.cssText += inlineCss;\n}\nfunction fadeout(el, t, callback) {\n  let inlineCss = createFaderInlineText(false, t, 'ease');\n  el.style.cssText += inlineCss;\n  console.log(t, ' inline is ', inlineCss);\n\n  // window.setTimeout(callback, t * 1000);\n  el.addEventListener('transitionend', callback, false);\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/utils/viewstream-animations.js?");

/***/ }),

/***/ "./src/spyne/utils/viewstream-lifecycle-observables.js":
/*!*************************************************************!*\
  !*** ./src/spyne/utils/viewstream-lifecycle-observables.js ***!
  \*************************************************************/
/*! exports provided: LifecyleObservables */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LifecyleObservables\", function() { return LifecyleObservables; });\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\nclass LifecyleObservables {\n  constructor(props) {\n    this.props.observableStreams = LifecyleObservables.createDirectionalObservables();\n  }\n\n  static createDirectionalFiltersObject() {\n    const dirInternal = 'internal';\n    const dirParent = 'parent';\n    const dirChild = 'child';\n    return {\n      P: [dirParent],\n      C: [dirChild],\n      PCI: [dirParent, dirInternal, dirChild],\n      CI: [dirChild, dirInternal],\n      PI: [dirParent, dirInternal],\n      PC: [dirParent, dirChild]\n    };\n  }\n\n  static addDefaultDir(obj) {\n    const defaults = R.flip(R.merge);\n    return defaults({$dir:['internal']}, R.clone(obj));\n  }\n\n  static addDownInternalDir(obj, arr = ['internal', 'down']) {\n    const defaults = R.flip(R.merge);\n    return defaults(R.clone(obj), {$dir:arr});\n  }\n\n  static addChildAndInternalDir(obj, arr = ['child', 'down']) {\n    const defaults = R.flip(R.merge);\n    return defaults(R.clone(obj), {$dir:arr});\n  }\n\n  static mapToDefaultDir(p) {\n    return this.addDefaultDir(p);\n  }\n\n  static createDirectionalObservables(obs$ = new Rx.Subject()) {\n    const filterStreams = val => R.propSatisfies(arrType => arrType.includes(val), '$dir');\n    const filterParent = filterStreams('parent');\n    const filterChild = filterStreams('child');\n    const filterInternal = filterStreams('internal');\n\n    const addfrom$ = relStr => R.merge({from$:relStr});\n    const addParentfrom$ = addfrom$('child');\n    const addInternalfrom$ = addfrom$('internal');\n    const addChildfrom$ = addfrom$('parent');\n\n    const raw$ =  obs$\n      .filter((payload) => payload !== undefined && payload.action !== undefined);\n    // .filter(p => p.$dir !== undefined)\n    // .do(p => console.log('payload : ', p.$dir, p));\n    const toInternal$ = obs$.filter(filterInternal).map(addInternalfrom$);\n    const toParent$ = obs$.filter(filterParent).map(addParentfrom$);\n    const toChild$ = obs$.filter(filterChild).map(addChildfrom$);\n    // const upObs$ = obs$.do(p => console.log('UP: ', p));\n    const streamObj = {\n      parent: toParent$,\n      internal: toInternal$,\n      child: toChild$\n    };\n\n    const completeStream = (arr = []) => {\n      const endStream = o => {\n        o.complete();\n        o.isStopped = true;\n      };\n\n      const setCompleteStream = (str) => {\n        if (streamObj[str] !== undefined) {\n          let obs$ = streamObj[str];\n          endStream(obs$);\n        }\n      };\n\n      if (arr !== undefined && arr.length >= 1) {\n        arr.forEach(setCompleteStream);\n      }\n    };\n    const completeAll = () => {\n      let completeStream = o => {\n        o.complete();\n        o.isStopped = true;\n      };\n      R.forEach(completeStream, [raw$, toInternal$, toParent$, toChild$]);\n    };\n\n    return {\n      raw$, toInternal$, toParent$, toChild$, completeAll, completeStream\n    };\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/utils/viewstream-lifecycle-observables.js?");

/***/ }),

/***/ "./src/spyne/views/dom-item-selectors.js":
/*!***********************************************!*\
  !*** ./src/spyne/views/dom-item-selectors.js ***!
  \***********************************************/
/*! exports provided: DomItemSelectors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DomItemSelectors\", function() { return DomItemSelectors; });\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n// const Rx = require('rxjs');\n\nclass DomItemSelectors {\n  constructor(cxt, str) {\n    this.el = str !== undefined ? cxt.querySelectorAll(str) : cxt;\n    this.queryStr = str;\n    if (this.el.length === 1) {\n      this.el = R.head(this.el);\n    } else if (this.el.constructor.name === 'NodeList') {\n      this.el = [...this.el];\n    }\n    this.cList = this.el.classList;\n\n    this.elProps = new Map();\n\n    this.createMethods();\n  }\n\n  createMethods() {\n    const mapAddClass = (item, s) => item.classList.add(s);\n    const mapRemoveClass = (item, s) => item.classList.remove(s);\n    const mapSetClass = (item, s) => {\n      item.classList.value = s;\n      return item;\n    };\n    const mapInlineCss = (item, s) => {\n      item.style.cssText = s;\n      return item;\n    };\n\n    this.addClass = this.mapToValue(mapAddClass);\n    this.removeClass = this.mapToValue(mapRemoveClass);\n    this.setClass = this.mapToValue(mapSetClass);\n    this.inlineCss = this.mapToValue(mapInlineCss);\n  }\n\n  mapMethod(fn) {\n    // Add a function to the class that will wait for a string param\n    return (str) => {\n      this.elArr.map(fn);\n      return this;\n    };\n  }\n\n  addAnimClass(str) {\n    const adder = () => this.addClass(str);\n    requestAnimationFrame(() => {\n      setTimeout(adder, 0);\n    });\n    return this;\n  }\n\n  mapToValue(f) {\n    return str => {\n      // console.log('str f this', str, f, this);\n      this.elArr.map(item => f(item, str));\n      return this;\n    };\n  }\n\n  setClassOnBool(str = '', bool = true) {\n    if (bool) {\n      this.addClass(str);\n    } else {\n      this.removeClass(str);\n    }\n    return this;\n  }\n\n  setActiveItem(query, str) {\n    const activeEl = document.querySelector(this.queryStr + query);\n    const filterForActive = item => item === activeEl;\n    // const onActive = bool => bool === true ? item.addClass(str) : item.removeClass(str);\n    const adder = (item) => {\n      item.classList.add(str);\n    };\n    const remover = (item) => {\n      item.classList.remove(str);\n    };\n    const mapTheActive = R.ifElse(\n      filterForActive,\n      adder,\n      remover\n    );\n\n    this.elArr.map(mapTheActive);\n  }\n\n  query(str) {\n    return new DomItemSelectors(this.el, str);\n  }\n\n  getEl() {\n    return this.el;\n  }\n\n  get elArr() {\n    // console.log('el arr is ', this.el);\n    if (this.el.constructor.name === 'NodeList') {\n      return [...this.el];\n    } else {\n      return [].concat(this.el);\n    }\n  }\n\n  getBoxEl() {\n    return [].concat(this.el);\n  }\n\n  unmount() {\n    this.el = undefined;\n    this.cList = undefined;\n    this.inline = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/views/dom-item-selectors.js?");

/***/ }),

/***/ "./src/spyne/views/dom-item.js":
/*!*************************************!*\
  !*** ./src/spyne/views/dom-item.js ***!
  \*************************************/
/*! exports provided: DomItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DomItem\", function() { return DomItem; });\n/* harmony import */ var _utils_mixins_base_core_mixins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mixins/base-core-mixins */ \"./src/spyne/utils/mixins/base-core-mixins.js\");\n/* harmony import */ var _dom_template_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-template-renderer */ \"./src/spyne/views/dom-template-renderer.js\");\n// import {createElement} from '../utils/dom-methods';\n\n\n// import {DomTemplateRenderer} from './template-renderer';\n\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n\nclass DomItem {\n  /**\n   * @module DomItem\n   *\n   * @desc\n   * This class is mostly used internally by the ViewStream object, but it can be also used to generate a lightweight dom element that contains no props or parameters.\n   *\n   * @constructor\n   * @param {string} tagName the tagname for this dom element.\n   * @param {object} attributes any domElement attribute (except for class )\n   * @param {string|object} content string for text tags and json for templates\n   * @param {template} template\n   */\n\n  constructor(tagName = 'div', attributes = {}, content = undefined, template = undefined) {\n    let isSimpleView = R.is(String, attributes);\n    if (isSimpleView === true) {\n      content = attributes;\n      attributes = {};\n    }\n    this.props = new Map();\n    this.setProp('fragment', document.createDocumentFragment());\n    this.setProp('tagName', tagName);\n    this.setProp('attrs', this.updateAttrs(attributes));\n    this.setProp('content', content);\n    this.setProp('template', template);\n    this.addMixins();\n  }\n\n  setProp(key, val) {\n    this.props.set(key, val);\n  }\n\n  getProp(val) {\n    return this.props.get(val);\n  }\n\n  get el() {\n    return this.props.get('el');\n  }\n\n  setElAttrs(el, params) {\n    let addAttributes = (val, key) => {\n      let addToDataset = (val, key) => { el.dataset[key] = val; };\n      if (key === 'dataset') {\n        R.forEachObjIndexed(addToDataset, val);\n      } else {\n        el.setAttribute(key, val);\n      }\n    };\n    this.getProp('attrs').forEach(addAttributes);\n    return el;\n  }\n\n  updateAttrs(params, m) {\n    let theMap = m !== undefined ? m : new Map();\n    let addAttributes = (val, key) => theMap.set(key, val);\n    R.mapObjIndexed(addAttributes, params);\n    return theMap;\n  }\n\n  addTemplate(el) {\n    let template = this.getProp('template');\n\n    let addTmpl = (template) => {\n      let data = this.getProp('content');\n      data = R.is(Object, data) ? data : {};\n\n      let frag = new _dom_template_renderer__WEBPACK_IMPORTED_MODULE_1__[\"DomTemplateRenderer\"](template, data).getTemplateNode();\n      el.appendChild(frag);\n      return el;\n    };\n    let doNothing = (el) => el;\n    return template !== undefined ? addTmpl(template) : doNothing(el);\n  }\n\n  createElement(tagName = 'div') {\n    return document.createElement(tagName);\n  }\n\n  addContent(el) {\n    let text = (this.getProp('content'));\n    let isText = R.is(String, text);\n    if (isText === true) {\n      let txt = document.createTextNode(text);\n      el.appendChild(txt);\n    }\n    return el;\n  }\n\n  execute() {\n    let el = R.pipe(\n      this.createElement.bind(this),\n      this.setElAttrs.bind(this),\n      this.addTemplate.bind(this),\n      this.addContent.bind(this)\n    )(this.getProp('tagName'));\n    // this.getProp('fragment').appendChild(el);\n    this.props.set('el', el);\n  }\n\n  render() {\n    this.execute();\n    return this.getProp('el');\n  }\n\n  returnIfDefined(obj, val) {\n    if (val !== undefined) {\n      let isObj = typeof (val) === 'undefined';\n      isObj === false ? obj[val] = val : obj[val] = Object.assign(obj[val], val);\n    }\n  }\n\n  updateprops(val) {\n    this.returnIfDefined(this.props, val);\n    return this;\n  }\n\n  updatepropsAndRun(val) {\n    this.updateprops(val);\n    this.execute();\n    return this.getProp('fragment');\n  }\n\n  unmount() {\n    if (this.props !== undefined) {\n      // console.log('dom item unmounting ', this, this.props);\n      this.getProp('el').remove();\n      this.props.clear();\n      this.gc();\n    }\n  }\n\n  updateTag(tagName = 'div') { this.updateprops(tagName); }\n  updateAttributes(attrs = {}) { this.updateprops(attrs); }\n  updateTemplate(template) { this.updateprops(template); }\n  updateData(data = {}) { this.updateprops(data); }\n  addTagAndRender(tagName = 'div') { this.updatepropsAndRun(tagName); }\n  addAttrsibutesAndRender(attrs = {}) { this.updatepropsAndRun(attrs); }\n  addTemplateAndRender(template) { this.updatepropsAndRun(template); }\n  addDataAndRender(data = {}) { this.updatepropsAndRun(data); }\n  //  ==================================\n  // BASE CORE MIXINS\n  //  ==================================\n  addMixins() {\n    let coreMixins = Object(_utils_mixins_base_core_mixins__WEBPACK_IMPORTED_MODULE_0__[\"baseCoreMixins\"])();\n    this.gc = coreMixins.gc.bind(this);\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/views/dom-item.js?");

/***/ }),

/***/ "./src/spyne/views/dom-template-renderer.js":
/*!**************************************************!*\
  !*** ./src/spyne/views/dom-template-renderer.js ***!
  \**************************************************/
/*! exports provided: DomTemplateRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DomTemplateRenderer\", function() { return DomTemplateRenderer; });\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n\nclass DomTemplateRenderer {\n  constructor(template, data) {\n    this.template = this.formatTemplate(template);\n    this.templateData = data;\n\n    let strArr = DomTemplateRenderer.getStringArray(this.template);\n\n    let strMatches = this.template.match(DomTemplateRenderer.findTmplLoopsRE());\n    strMatches = strMatches === null ? [] : strMatches;\n\n    const mapTmplLoop = (str, data) => str.replace(\n      DomTemplateRenderer.parseTmplLoopsRE(),\n      this.parseTheTmplLoop.bind(this));\n    const findTmplLoopsPred = R.contains(R.__, strMatches);\n\n    const checkForMatches = R.ifElse(\n      findTmplLoopsPred,\n      mapTmplLoop,\n      this.addParams.bind(this));\n\n    this.finalArr = strArr.map(checkForMatches);\n  }\n\n  static getStringArray(template) {\n    let strArr = template.split(DomTemplateRenderer.findTmplLoopsRE());\n    const emptyRE = /^([\\\\n\\s\\W]+)$/;\n    const filterOutEmptyStrings = s => s.match(emptyRE);\n    return R.reject(filterOutEmptyStrings, strArr);\n  }\n\n  static findTmplLoopsRE() {\n    return /({{#\\w+}}[\\w\\n\\s\\W]+?{{\\/\\w+}})/gm;\n  }\n\n  static parseTmplLoopsRE() {\n    return /({{#(\\w+)}})([\\w\\n\\s\\W]+?)({{\\/\\2}})/gm;\n  }\n\n  static swapParamsForTagsRE() {\n    return /({{)(.*?)(}})/gm;\n  }\n\n  removeThis() {\n    this.finalArr = undefined;\n    this.templateData = undefined;\n    this.template = undefined;\n  }\n\n  getTemplateNode() {\n    const html = this.finalArr.join(' ');\n    const el = document.createRange().createContextualFragment(html);\n    window.setTimeout(this.removeThis(), 10);\n    return el;\n  }\n\n  getTemplateString() {\n    return this.finalArr.join(' ');\n  }\n\n  formatTemplate(template) {\n    return typeof (template) === 'string' ? template : template.text;\n  }\n\n  addParams(str) {\n    const replaceTags = (str, p1, p2, p3) => {\n      let dataVal = this.templateData[p2];\n      let defaultIsEmptyStr = R.defaultTo('');\n      return defaultIsEmptyStr(dataVal);\n    };\n\n    return str.replace(DomTemplateRenderer.swapParamsForTagsRE(), replaceTags);\n  }\n\n  parseTheTmplLoop(str, p1, p2, p3) {\n    const subStr = p3;\n    let elData = this.templateData[p2];\n    const parseString = (item, str) => {\n      return str.replace(DomTemplateRenderer.swapParamsForTagsRE(), item);\n    };\n    const parseObject = (obj, str) => {\n      const loopObj = (str, p1, p2) => {\n        return obj[p2];\n      };\n      return str.replace(DomTemplateRenderer.swapParamsForTagsRE(), loopObj);\n    };\n    const mapStringData = (d) => {\n      if (typeof (d) === 'string') {\n        d = parseString(d, subStr);\n      } else {\n        d = parseObject(d, subStr);\n      }\n      return d;\n    };\n    return elData.map(mapStringData).join(' ');\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/views/dom-template-renderer.js?");

/***/ }),

/***/ "./src/spyne/views/view-stream-broadcaster.js":
/*!****************************************************!*\
  !*** ./src/spyne/views/view-stream-broadcaster.js ***!
  \****************************************************/
/*! exports provided: ViewStreamBroadcaster */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewStreamBroadcaster\", function() { return ViewStreamBroadcaster; });\n/* harmony import */ var _utils_mixins_base_streams_mixins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mixins/base-streams-mixins */ \"./src/spyne/utils/mixins/base-streams-mixins.js\");\n/* harmony import */ var _utils_frp_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/frp-tools */ \"./src/spyne/utils/frp-tools.js\");\n\n\n\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n\nclass ViewStreamBroadcaster {\n  constructor(props, broadcastFn) {\n    this.addMixins();\n    this.props = props;\n    this.broadcastFn = broadcastFn;\n    this.broadcaster(this.broadcastFn);\n  }\n\n  addDblClickEvt(q) {\n    let dblclick$ = Rx.Observable.fromEvent(q, 'click');\n    // console.log('ADDING DBL CLICK ', q);\n    let stream$ = dblclick$.buffer(dblclick$.debounceTime(250))\n      .filter(p => p.length === 2)\n      .map(p => p[0]);\n    return stream$;\n  }\n\n  //  ==================================================================\n  // BROADCAST BUTTON EVENTS\n  //  ==================================================================\n  broadcast(args) {\n    // payloads to send, based on either the array or the elements dataMap\n    let channelPayloads = {\n      'UI': this.sendUIPayload,\n      'ROUTE': this.sendRoutePayload\n    };\n    // spread operator to select variables from arrays\n    let [selector, event, chnl, data] = args;\n    // btn query\n    // let query = this.props.el.querySelectorAll(selector);\n    let channel; // hoist channel and later check if chnl exists\n    let query = this.props.el.querySelectorAll(selector);\n    let addObservable = (q) => {\n      // the  btn observable\n      let observable = event !== 'dblClick'\n        ? Rx.Observable.fromEvent(q, event)\n        : this.addDblClickEvt(q);\n      // select channel and data values from either the array or the element's dom Map\n      channel = Object(_utils_frp_tools__WEBPACK_IMPORTED_MODULE_1__[\"ifNilThenUpdate\"])(chnl, q.dataset.channel);\n      data = {};// convertDomStringMapToObj(q.dataset);\n      data['payload'] = Object(_utils_frp_tools__WEBPACK_IMPORTED_MODULE_1__[\"convertDomStringMapToObj\"])(q.dataset);\n      data.payload = R.omit(['channel'], data.payload);\n      data['channel'] = channel;\n      // payload needs cid# to pass verification\n\n      // data['event'] = event;\n      // data['el'] = q;\n      data['srcElement'] = {};// R.pick(['cid','viewName'], data);\n      data.srcElement['cid'] = this.props.id;\n      data.srcElement['viewName'] = this.props.name;\n      data.srcElement['event'] = event;\n      data.srcElement['el'] = q;\n      // select the correct payload\n      let channelPayload = channel !== undefined ? channelPayloads[channel] : channelPayloads['UI'];\n      // run payload\n      channelPayload(observable, data);\n    };\n\n    if (query === undefined || query.length <= 0) {\n      query = this.props.el;\n      addObservable(query, event);\n    } else {\n      query.forEach = Array.prototype.forEach;\n      query.forEach(addObservable);\n    }\n  }\n\n  broadcaster(arrFn) {\n    let broadcastArr = arrFn();\n    broadcastArr.forEach(args => this.broadcast(args));\n  }\n\n  //  =================================================================\n  addMixins() {\n    //  ==================================\n    // BASE STREAM MIXINS\n    //  ==================================\n    let streamMixins = Object(_utils_mixins_base_streams_mixins__WEBPACK_IMPORTED_MODULE_0__[\"baseStreamsMixins\"])();\n    this.sendUIPayload = streamMixins.sendUIPayload;\n    this.sendRoutePayload = streamMixins.sendRoutePayload;\n    this.createLifeStreamPayload = streamMixins.createLifeStreamPayload;\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/views/view-stream-broadcaster.js?");

/***/ }),

/***/ "./src/spyne/views/view-stream-enhancer-loader.js":
/*!********************************************************!*\
  !*** ./src/spyne/views/view-stream-enhancer-loader.js ***!
  \********************************************************/
/*! exports provided: ViewStreamEnhancerLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewStreamEnhancerLoader\", function() { return ViewStreamEnhancerLoader; });\n/* harmony import */ var _utils_frp_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/frp-tools */ \"./src/spyne/utils/frp-tools.js\");\n\n\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n\nclass ViewStreamEnhancerLoader {\n  constructor(parent, enhancersArr) {\n    this.context = parent;\n    this.enhancersMap = new Map();\n    this.enhancersArr = enhancersArr;\n\n    this.initMap();\n    this.addAllEnhancerMethods();\n  }\n\n  initMap() {\n    this.enhancersMap.set('ALL', []);\n    let allMethodsArr = Object(_utils_frp_tools__WEBPACK_IMPORTED_MODULE_0__[\"getAllMethodNames\"])(this.context).allMethods;\n    this.updateMap('LOCAL', allMethodsArr);\n  }\n\n  getEnhancersMap() {\n    return this.enhancersMap;\n  }\n\n  updateMap(name, arr) {\n    let allArr = R.concat(this.enhancersMap.get('ALL'), arr);\n    this.enhancersMap.set(name, arr);\n    this.enhancersMap.set('ALL', allArr);\n  }\n\n  getMethodsArr(str) {\n    return this.enhancersMap.get(str);\n  }\n\n  createEnhancerMethodsObj(EnhancerClass) {\n    const sendError = str => console.error(\n      `Spyne Error: The following enhancer method, \"${str}\", already exists and cannot be added to the ${enhancer.name} Enhancer!`);\n    let enhancer = new EnhancerClass(this.context);\n\n    const validateMethods = arr => {\n      let methodsExistsFilter = R.contains(R.__, this.getMethodsArr('ALL'));\n      let dupedMethods = R.filter(methodsExistsFilter, arr);\n      dupedMethods.forEach(sendError);\n      return dupedMethods;\n    };\n\n    let enhancerMethodsObj = enhancer.getEnhancerMethods();\n    let dupedMethodsArr = validateMethods(enhancerMethodsObj.allMethods);\n    let dropDupedMethodsFromArr = R.dropWhile(\n      R.contains(R.__, dupedMethodsArr));\n\n    enhancerMethodsObj = R.map(dropDupedMethodsFromArr, enhancerMethodsObj);\n\n    this.updateMap(enhancer.name, enhancerMethodsObj.allMethods);\n\n    enhancerMethodsObj['enhancer'] = enhancer;\n    enhancerMethodsObj['name'] = enhancer.name;\n\n    return enhancerMethodsObj;\n  }\n\n  addAllEnhancerMethods() {\n    const addEnhancerMethods = (enhancerClass) => {\n      let enhancerMethodsObj = this.createEnhancerMethodsObj(enhancerClass);\n      let enhancer = enhancerMethodsObj.enhancer;\n      enhancer.bindParentViewStream(enhancerMethodsObj, this.context);\n    };\n\n    R.forEach(addEnhancerMethods, this.enhancersArr);\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/views/view-stream-enhancer-loader.js?");

/***/ }),

/***/ "./src/spyne/views/view-stream.js":
/*!****************************************!*\
  !*** ./src/spyne/views/view-stream.js ***!
  \****************************************/
/*! exports provided: ViewStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewStream\", function() { return ViewStream; });\n/* harmony import */ var _utils_mixins_base_core_mixins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mixins/base-core-mixins */ \"./src/spyne/utils/mixins/base-core-mixins.js\");\n/* harmony import */ var _utils_mixins_base_streams_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixins/base-streams-mixins */ \"./src/spyne/utils/mixins/base-streams-mixins.js\");\n/* harmony import */ var _utils_frp_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/frp-tools */ \"./src/spyne/utils/frp-tools.js\");\n/* harmony import */ var _view_to_dom_mediator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./view-to-dom-mediator */ \"./src/spyne/views/view-to-dom-mediator.js\");\n/* harmony import */ var _view_stream_enhancer_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./view-stream-enhancer-loader */ \"./src/spyne/views/view-stream-enhancer-loader.js\");\n/* harmony import */ var _channels_channels_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../channels/channels-config */ \"./src/spyne/channels/channels-config.js\");\n/* harmony import */ var _view_stream_broadcaster__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./view-stream-broadcaster */ \"./src/spyne/views/view-stream-broadcaster.js\");\n/* harmony import */ var _channels_channels_payload__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../channels/channels-payload */ \"./src/spyne/channels/channels-payload.js\");\n/* harmony import */ var _utils_viewstream_lifecycle_observables__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/viewstream-lifecycle-observables */ \"./src/spyne/utils/viewstream-lifecycle-observables.js\");\n/* harmony import */ var _dom_item_selectors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dom-item-selectors */ \"./src/spyne/views/dom-item-selectors.js\");\n\n\n\n// import {gc} from '../utils/gc';\n\n\n\n\n\n\n\n\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n\nclass ViewStream {\n  /**\n   * @module ViewStream\n   *\n   * @desc\n   * The ViewStream object creates or references  a dom elment; the dom element can be as simple as a &#60;p&gt; tag, or the dom element can be a large dom chunk that is generated from data and an html template.\n   * <br><br>\n   * Generally, the idea is to extend the ViewStream class and add the custom values within the constructor function, but all of the values can be passed as parameters as well.\n   *\n   * @example\n   * // returns <h2>Hello World</h2>\n   * new ViewStream({tagName:'h2', data:'Hello World'};\n   * @example\n   * //  returns\n   * <ul>\n   *    <li>firstName: Jane<li>\n   *    <li>lastName: Doe<li>\n   *    <li>Age: 23<li>\n   * </ul>\n   *\n   * let myTemplate = '<li>firstName: {{fName}}<li>lastName: {{lName}}<li>Age: {{age}}';\n   * let myData = {fName: Jane, lName: Doe, age:23};\n   * new ViewStream({tagName:'ul', data:myData, template:myTemplate});\n   *\n   *\n   *\n   * @constructor\n   * @param {object} props This json object takes in parameters to generate or reference the dom element\n   * @property {string} props.tagName  - 'div'  This can be any dom tag\n   * @property {domItem} props.el undefined, if defined, ViewStream will connect to that element\n   * @property {string|object} props.data undefined, // string for innerText or Json object for html template\n   * @property {boolean} props.animateIn - false, animates in View\n   * @property {number} props.animateInTime - .5\n   * @property {boolean} props.animateOut false, animates in View\n   * @property {number} props.animateOutTime .5\n   * @property {string} props.id - undefined, generates a random id if left undefined\n   * @property {boolean} props.debug false\n   * @property {template} props.template undefined, // html template\n   *\n   */\n  constructor(props = {}) {\n    this.checker = Math.random();\n    this.addMixins();\n    this.defaults = () => {\n      const cid = this.createId();\n      const id = props.id ? props.id : cid;\n      return {\n        cid,\n        id,\n        tagName: 'div',\n        el: undefined,\n        data: undefined,\n        animateIn: false,\n        animateInTime: 0.5,\n        animateOut: false,\n        animateOutTime: 0.5,\n        hashId: `#${id}`,\n        viewClass: _view_to_dom_mediator__WEBPACK_IMPORTED_MODULE_3__[\"ViewToDomMediator\"],\n        extendedSourcesHashMethods: {},\n        debug: false,\n        template: undefined,\n        node: document.createDocumentFragment(),\n        name: this.constructor.name\n      };\n    };\n    this._state = {};\n    this.$dirs = _utils_viewstream_lifecycle_observables__WEBPACK_IMPORTED_MODULE_8__[\"LifecyleObservables\"].createDirectionalFiltersObject();\n    this.addDefaultDirection = _utils_viewstream_lifecycle_observables__WEBPACK_IMPORTED_MODULE_8__[\"LifecyleObservables\"].addDefaultDir;\n    this.addDownInternalDir = _utils_viewstream_lifecycle_observables__WEBPACK_IMPORTED_MODULE_8__[\"LifecyleObservables\"].addDownInternalDir;\n    this.props = Object.assign({}, this.defaults(), props);\n    this.props['domAttributes'] = R.pick(['id', 'class', 'dataset'],\n      this.props);\n    this.loadEnhancers();\n    this.loadAllMethods();\n    this.props.action = 'LOADED';\n    this.sink$ = new Rx.Subject();\n    const ViewClass = this.props.viewClass;\n    this.view = new ViewClass(this.sink$, {}, this.checker,\n      this.constructor.name);// new this.props.viewClass(this.sink$);\n    this.sourceStreams = this.view.sourceStreams;\n    this._rawSource$ = this.view.getSourceStream();\n    this._rawSource$['viewName'] = this.props.name;\n    this.sendEventsDownStream = this.sendEventsDownStreamFn;\n    this.init();\n    this.checkIfElementAlreadyExists();\n  }\n\n  checkIfElementAlreadyExists() {\n    const elIsDomElement = el => el !== undefined && el.tagName !== undefined;\n    const elIsRendered = el => document.body.contains(el);\n    const elIsReadyBool = R.propSatisfies(\n      R.allPass([elIsRendered, elIsDomElement]), 'el');\n    if (elIsReadyBool(this.props)) {\n      this.postRender();\n    }\n  }\n\n  loadEnhancers(arr = []) {\n    let enhancerLoader = new _view_stream_enhancer_loader__WEBPACK_IMPORTED_MODULE_4__[\"ViewStreamEnhancerLoader\"](this, arr);\n    this.props['enhancersMap'] = enhancerLoader.getEnhancersMap();\n    enhancerLoader = undefined;\n  }\n\n  loadAllMethods() {\n    const channelFn = R.curry(this.onChannelMethodCall.bind(this));\n    let createExtraStatesMethod = (arr) => {\n      let [action, funcStr, enhancer] = arr;\n      let defaultEnhancer = R.defaultTo('LOCAL');\n      this.props.extendedSourcesHashMethods[action] = channelFn(funcStr,\n        defaultEnhancer(enhancer));\n    };\n    this.addActionMethods().forEach(createExtraStatesMethod);\n    this.props.hashSourceMethods = this.setSourceHashMethods(\n      this.props.extendedSourcesHashMethods);\n  }\n\n  addActionMethods() {\n    return [];\n  }\n\n  onChannelMethodCall(str, enhancer, p) {\n    if (p.$dir !== undefined && p.$dir.includes('child') &&\n        this.deleted !== true) {\n      let obj = Object.assign({}, p);\n      obj['$dir'] = this.$dirs.C;\n      this.sourceStreams.raw$.next(obj);\n    }\n\n    const methodsArr = this.props.enhancersMap.get(enhancer);\n    if (R.contains(str, methodsArr) === false) {\n      console.warn(\n        `Spyne Warning: The method, \"${str}\", does not appear to exist in ${enhancer} file! `);\n    } else {\n      this[str](p);\n    }\n  }\n\n  setSourceHashMethods(extendedSourcesHashMethods = {}) {\n    let hashSourceKeys = {\n      'DISPOSING': (p) => this.checkParentDispose(p),\n      'DISPOSE': (p) => this.onDispose(p),\n      // 'CHILD_DISPOSE'                    : (p) => this.onDispose(p),\n      'RENDERED': (p) => this.onRendered(p),\n      'RENDERED_AND_ATTACHED_TO_DOM': (p) => this.onRendered(p),\n      'RENDERED_AND_ATTACHED_TO_PARENT': (p) => this.onRendered(p),\n      // 'CHILD_RENDERED'                   : (p) => this.attachChildToView(p),\n      'READY_FOR_GC': (p) => this.onReadyToGC(p),\n      'NOTHING': () => ({})\n    };\n    return Object.assign({}, hashSourceKeys, extendedSourcesHashMethods);\n  }\n\n  //  =====================================================================\n  // ====================== MAIN STREAM METHODS ==========================\n  init() {\n    this._source$ = this._rawSource$.map(\n      (payload) => this.onMapViewSource(payload)).takeWhile(this.notGCSTATE);\n\n    this.initAutoMergeSourceStreams();\n    this.updateSourceSubscription(this._source$, true);\n  }\n\n  notGCSTATE(p) {\n    return !p.action.includes('READY_FOR_GC');\n  }\n\n  eqGCSTATE(p) {\n    return !p.action.includes('READY_FOR_GC');\n  }\n\n  notCOMPLETED(p) {\n    return !p.action.includes('COMPLETED');\n  }\n\n  notGCCOMPLETE(p) {\n    return !p.action.includes('GC_COMPLETE');\n  }\n\n  testVal(p) {\n    console.log('TESTING VALL IS ', p);\n  }\n\n  addParentStream(obs, attachData) {\n    let filterOutNullData = (data) => data !== undefined && data.action !==\n        undefined;\n    let checkIfDisposeOrFadeout = (d) => {\n      let data = Object.assign({}, d);\n\n      if (data.action === 'DISPOSE_AND_READY_FOR_GC') {\n        this.onDispose(data);\n        data.action = 'READY_FOR_GC';\n      }\n      return data;\n    };\n\n    this.parent$ = obs.filter(filterOutNullData)\n      .map(checkIfDisposeOrFadeout)\n      .takeWhile(this.notGCCOMPLETE);\n    this.updateSourceSubscription(this.parent$, false, 'PARENT');\n    this.renderAndAttachToParent(attachData);\n  }\n\n  addChildStream(obs$) {\n    let filterOutNullData = (data) => data !== undefined && data.action !==\n        undefined;\n    let child$ = obs$.filter(filterOutNullData)\n      .do(p => this.tracer('addChildStraem do ', p))\n      .map((p) => {\n        return p;\n      })\n      // .takeWhile(this.notGCSTATE)\n      .finally(p => this.onChildCompleted(child$.source));\n    this.updateSourceSubscription(child$, true, 'CHILD');\n  }\n\n  onChildCompleted(p) {\n    let findName = (x) => {\n      let finalDest = (y) => {\n        while (y.destination !== undefined) {\n          y = finalDest(y.destination);\n        }\n        return y;\n      };\n      return finalDest(x).viewName;\n    };\n    // let childCompletedName = findName(p);\n    this.tracer('onChildCompleted ', this.checker, p);\n    return findName(p);\n  }\n\n  initAutoMergeSourceStreams() {\n    // ====================== SUBSCRIPTION SOURCE =========================\n    let subscriber = {\n      next: this.onSubscribeToSourcesNext.bind(this),\n      error: this.onSubscribeToSourcesError.bind(this),\n      complete: this.onSubscribeToSourcesComplete.bind(this)\n    };\n    // let takeBeforeGCOld = (val) => val.action !== 'GARBAGE_COLLECTED';\n    // let takeBeforeGC = (p) => !p.action.includes('READY_FOR_GC');\n    // let mapToState = (val) => ({action:val});\n    //  =====================================================================\n    // ========== METHODS TO CHECK FOR WHEN TO COMPLETE THE STREAM =========\n    let completeAll = () => {\n      this.uberSource$.complete();\n      this.autoSubscriber$.complete();\n      this.sink$.complete();\n      this.props.el$.unmount();\n      this.props = undefined;\n      this.deleted = true;\n      this.tracer('completeAll', this.deleted, this.props);\n    };\n    let decrementOnObservableClosed = () => {\n      obsCount -= 1;\n      if (obsCount === 0) {\n        completeAll();\n      }\n    };\n    //  =====================================================================\n    // ======================== INIT STREAM METHODS ========================\n    let obsCount = 0;\n    this.uberSource$ = new Rx.Subject();\n    // ======================= COMPOSED RXJS OBSERVABLE ======================\n    let incrementObservablesThatCloses = () => { obsCount += 1; };\n    this.autoMergeSubject$ = this.uberSource$.mergeMap((obsData) => {\n      let branchObservable$ = obsData.observable.filter(\n        (p) => p !== undefined && p.action !== undefined).map(p => {\n        // console.log('PAYLOAD IS ', p, this.constructor.name)\n        let payload = Object.assign({}, p);\n        payload.action = p.action;// addRelationToState(obsData.rel, p.action);\n        this.tracer('autoMergeSubject$', payload);\n        return payload;\n      });\n\n      if (obsData.autoClosesBool === false) {\n        return branchObservable$;\n      } else {\n        incrementObservablesThatCloses();\n        return branchObservable$.finally(decrementOnObservableClosed);\n      }\n    });\n    // ============================= SUBSCRIBER ==============================\n    this.autoSubscriber$ = this.autoMergeSubject$\n    // .do((p) => console.log('SINK DATA ', this.constructor.name, p))\n      .filter((p) => p !== undefined && p.action !== undefined)\n      .subscribe(subscriber);\n  }\n\n  // ========================= MERGE STREAMS TO MAIN SUBSCRIBER =================\n  updateSourceSubscription(obs$, autoClosesBool = false, rel) {\n    // const directionArr = sendDownStream === true ? this.$dirs.DI : this.$dirs.I;\n    let obj = {\n      observable: obs$,\n      autoClosesBool,\n      rel\n    };\n    this.tracer('updateSourceSubscription ', this.checker, obj);\n    this.uberSource$.next(obj);\n  }\n\n  // ============================= SUBSCRIBER METHODS ==============================\n  onSubscribeToSourcesNext(payload = {}) {\n    let defaultToFn = R.defaultTo((p) => this.sendExtendedStreams(p));\n\n    // ****USE REGEX AS PREDICATE CHECK FOR PAYLOAD.ACTION IN HASH METHODS OBJ\n    // const hashAction = this.props.hashSourceMethods[payload.action];\n    const hashActionStr = Object(_utils_frp_tools__WEBPACK_IMPORTED_MODULE_2__[\"findStrOrRegexMatchStr\"])(this.props.hashSourceMethods,\n      payload.action);\n    const hashAction = this.props.hashSourceMethods[hashActionStr];\n    // console.log('S PAYLOAD ', this.props.name, typeof (hashAction), payload);\n\n    let fn = defaultToFn(hashAction);\n\n    // console.log('hash methods ', fn, this.props.name, payload.action, hashActionStr, this.props.hashSourceMethods);\n\n    fn(payload);\n    // console.log(fn, payload, ' THE PAYLOAD FROM SUBSCRIBE IS ', ' ---- ', ' ---> ', this.props);\n    // console.log('DISPOSER VS NEXT', this.constructor.name, payload);\n\n    this.tracer('onSubscribeToSourcesNext', {payload});\n  }\n\n  onSubscribeToSourcesError(payload = '') {\n    console.log('ALL ERROR  ', this.constructor.name, payload);\n  }\n\n  onSubscribeToSourcesComplete() {\n    // console.log('==== DISPOSER ALL COMPLETED ====', this.constructor.name);\n    this.tracer('onSubscribeToSourcesComplete', 'GARBAGE_COLLECT');\n\n    this.openSpigot('GARBAGE_COLLECT');\n  }\n\n  //  =======================================================================================\n  // ============================= HASH KEY AND SPIGOT METHODS==============================\n  get source$() {\n    return this._source$;\n  }\n\n  sendExtendedStreams(payload) {\n    this.tracer('sendExtendedStreams', payload);\n    // console.log('extended methods ', payload.action, payload);\n    this.openSpigot(payload.action, payload);\n  }\n\n  // ===================================== RENDER METHODS ==================================\n  renderAndAttachToParent(attachData) {\n    // let childRenderData = attachData;\n    this.openSpigot('RENDER_AND_ATTACH_TO_PARENT', attachData);\n  }\n\n  renderView() {\n    this.openSpigot('RENDER');\n  }\n\n  renderViewAndAttachToDom(node, type, attachType) {\n    let attachData = {node, type, attachType};\n    this.openSpigot('RENDER_AND_ATTACH_TO_DOM', {attachData});\n  }\n\n  attachChildToView(data) {\n    // let childRenderData = data.attachData;\n    // console.log('CHILD DATA ', this.constructor.name, childRenderData);\n    // this.openSpigot('ATTACH_CHILD_TO_SELF', {childRenderData});\n  }\n\n  // ===================================== DISPOSE METHODS =================================\n  checkParentDispose(p) {\n    if (p.from$ === 'parent') {\n      this.onDispose(p);\n    }\n  }\n\n  onDispose(p) {\n    // console.log('DISPOSER VS onDispose ', this.constructor.name);\n\n    this.openSpigot('DISPOSE');\n  }\n\n  onChildDispose(p) {\n  }\n\n  onParentDisposing(p) {\n    // this.updateSourceSubscription(this._source$);\n    this.openSpigot('DISPOSE');\n  }\n\n  onReadyToGC(p) {\n    const isInternal = p.from$ !== undefined && p.from$ === 'internal';\n    if (isInternal) {\n      // this.openSpigot('GARBAGE_COLLECT');\n    }\n    this.tracer('onReadyToGC', isInternal, p);\n  }\n\n  // ===================================== SINK$ METHODS =================================\n\n  sendEventsDownStreamFn(o, action = {}) {\n    // console.log('OBJ ACTION ', o, action);\n    let obj = Object.assign({action}, o);\n    // obj['action'] = action;\n    obj['$dir'] = this.$dirs.C;\n    // console.log('OBJ FINAL ', obj);\n    this.sourceStreams.raw$.next(obj);\n  }\n\n  openSpigot(action, obj = {}) {\n    if (this.props !== undefined) {\n      this.props.action = action;\n      let data = R.merge(this.props, obj);\n      this.sink$.next(Object.freeze(data));\n    }\n  }\n\n  setAttachData(attachType, query) {\n    return {\n      node: this.props.el,\n      type: 'ViewToDomMediator',\n      attachType,\n      query: this.props.el.querySelector(query)\n    };\n  }\n\n  getParentEls(el, num) {\n    let getElem = el => el.parentElement;\n    let iter = 0;\n    let parentEl = el;\n    while (iter < num) {\n      parentEl = getElem(parentEl);\n      iter++;\n    }\n    return parentEl;\n  }\n\n  setAttachParentData(attachType, query, level) {\n    return {\n      node: this.getParentEls(this.props.el, level),\n      type: 'ViewToDomMediator',\n      attachType,\n      query: this.props.el.parentElement.querySelector(query)\n    };\n  }\n\n  onMapViewSource(payload = {}) {\n    this.props = R.merge(this.props, payload);\n    return payload;\n  }\n\n  // ====================== ATTACH STREAM AND DOM DATA AGGREGATORS==========================\n  exchangeViewsWithChild(childView, attachData) {\n    this.addChildStream(childView.sourceStreams.toParent$);\n    childView.addParentStream(this.sourceStreams.toChild$, attachData);\n  }\n\n  /**\n   *  Appends a ViewStream object to an existing dom element.\n   *  @param {dom} node the ViewStream child that is to be attached.\n   * @example\n   * //  returns\n   * <body>\n   *    <h2>Hello World</h2>\n   * </body>\n   *\n   * let viewStream = new ViewStream('h2', 'Hello World');\n   * viewStream.appendToDom(document.body);\n   *\n   */\n  appendToDom(node) {\n    this.renderViewAndAttachToDom(node, 'dom', 'appendChild');\n  }\n\n  /**\n   * Prepends the current ViewStream object to an existing dom element.\n   * @param {dom} node the ViewStream child that is to be attached.\n   *\n   * @example\n   * this.prependToDom(document.body);\n   *\n   */\n\n  prependToDom(node) {\n    this.renderViewAndAttachToDom(node, 'dom', 'prependChild');\n  }\n\n  /**\n   * This method appends a child ViewStream object. <br>After the attachment, rxjs observables are exchanged between the parent and child ViewStream objects.<br><br>\n   * @param {ViewStream} v the ViewStream child that is to be attached.\n   * @param {string} query a querySelector within this ViewStream.\n   *\n   * @example\n   * //  returns\n   * <body>\n   *    <main>\n   *        <h2>Hello World</h2>\n   *    </main>\n   * </body>\n   *\n   *\n   * let parentView = new ViewStream('main');\n   * parentView.appendToDom(document.body);\n   *\n   * let childView = new ViewStream({tagName:'h2', data:'Hello World'};\n   * parentView.appendView(childView)\n   *\n   * */\n  appendView(v, query) {\n    this.exchangeViewsWithChild(v, this.setAttachData('appendChild', query));\n  }\n\n  /**\n   * This method appends a child ViewStream object to a parent ViewStream object.\n   * @param {ViewStream} v the ViewStream parent.\n   * @param {string} query a querySelector within this ViewStream.\n   * @param {level} this parameters can attach the viewStream's dom element up the dom tree while still maintaining the parent-child relationship of the ViewStream objects.\n   *\n   * @example\n   * //  returns\n   * <body>\n   *    <main>\n   *        <h2>Hello World</h2>\n   *    </main>\n   * </body>\n   *\n   *\n   * let parentView = new ViewStream('main');\n   * parentView.appendToDom(document.body);\n   *\n   * let childView = new ViewStream({tagName:'h2', data:'Hello World'};\n   * childView.appendToParent(parentView)\n   *\n   * */\n\n  appendViewToParent(v, query, level = 1) {\n    this.exchangeViewsWithChild(v,\n      this.setAttachParentData('appendChild', query, level));\n  }\n\n  /**\n   * This method prepends a child ViewStream object to a parent ViewStream object.\n   * @param {ViewStream} v the ViewStream parent.\n   * @param {string} query a querySelector within this ViewStream.\n   * @param {number} level this parameter can attach the viewStream's dom element up the dom tree while still maintaining the parent-child relationship of the ViewStream objects.\n   *\n   * @example\n   * let parentView = new ViewStream('main');\n   * parentView.prependToDom(document.body);\n   *\n   * let childView = new ViewStream({tagName:'h2', data:'Hello World'};\n   * childView.prependViewToParent(parentView)\n   *\n   * */\n  prependViewToParent(v, query, level = 1) {\n    this.exchangeViewsWithChild(v,\n      this.setAttachParentData('prependChild', query, level));\n  }\n\n  /**\n   *\n   *\n   * This method prepends a child ViewStream object to the current ViewStream object. <br>After the attachment, rxjs observables are exchanged between the parent and child ViewStream objects.<br><br>\n   * @param {ViewStream} v the ViewStream child that is to be attached.\n   * @param {string} query a querySelector within this ViewStream.\n   *\n   * @example\n   * //  returns\n   * <body>\n   *    <main>\n   *        <h2>Hello World</h2>\n   *    </main>\n   * </body>\n   *\n   * let parentView = new ViewStream('main');\n   * parentView.appendToDom(document.body);\n   *\n   * let childView = new ViewStream({tagName:'h2', data:'Hello World'};\n   * parentView.prependView(childView);\n   *\n   * */\n\n  prependView(v, query) {\n    this.exchangeViewsWithChild(v, this.setAttachData('prependChild', query));\n  }\n\n  onRendered(payload) {\n    // console.log('RENDER: ', this.props.name, payload);\n    if (payload.from$ === 'internal') {\n      // this.props['el'] = payload.el.el;\n\n      this.postRender();\n      // this.broadcaster = new Spyne.ViewStreamBroadcaster(this.props, this.broadcastEvents);\n    }\n  }\n\n  postRender() {\n    this.beforeAfterRender();\n    this.afterRender();\n    this.viewsStreamBroadcaster = new _view_stream_broadcaster__WEBPACK_IMPORTED_MODULE_6__[\"ViewStreamBroadcaster\"](this.props,\n      this.broadcastEvents);\n  }\n\n  beforeAfterRender() {\n    this.props.el$ = new _dom_item_selectors__WEBPACK_IMPORTED_MODULE_9__[\"DomItemSelectors\"](this.props.el);\n\n    // console.log('EL IS ', this.props.el$.elArr);\n    // window.theEl$ = this.props.el$;\n  }\n\n  // ================================= METHODS TO BE EXTENDED ==============================\n  /**\n   *\n   * This method is called once the ViewStream's domElement has been rendered and attached to the dom.\n   * <br>\n   * This method is empty and is meant to be overridden.\n   *\n   * */\n\n  // THIS IS AN EVENT HOLDER METHOD BECAUSE SENDING DOWNSTREAM REQUIRE THE PARENT TO HAVE A METHOD\n  downStream() {\n\n  }\n\n  afterRender() {\n  }\n\n  /**\n   *\n   * Add any query within the ViewStream's dom and any dom events to automatically be observed by the UI Channel.\n   * <br>\n   * @example\n   *\n   *  broadcastEvents() {\n     *  // ADD BUTTON EVENTS AS NESTED ARRAYS\n     *  return [\n     *       ['#my-button', 'mouseover'],\n     *       ['#my-input', 'change']\n     *     ]\n     *   }\n   *\n   *\n   * */\n\n  broadcastEvents() {\n    // ADD BUTTON EVENTS AS NESTED ARRAYS\n    return [];\n  }\n\n  /**\n   *\n   * Automatically connect to an instance of registered channels, such as 'DOM', 'UI', and 'ROUTE' channels.\n   *\n   *\n   * @example\n   *\n   * let uiChannel = this.getChannel('UI');\n   *\n   * uiChannel\n   *    .filter((p) => p.data.id==='#my-button')\n   *    .subscribe((p) => console.log('my button was clicked ', p));\n   *\n   * */\n\n  getChannel(channel) {\n    let isValidChannel = c => Object(_channels_channels_config__WEBPACK_IMPORTED_MODULE_5__[\"registeredStreamNames\"])().includes(c);\n    let error = c => console.warn(\n      `channel name ${c} is not within ${_channels_channels_config__WEBPACK_IMPORTED_MODULE_5__[\"registeredStreamNames\"]}`);\n    let startSubscribe = (c) => {\n      return window.Spyne.channels.getStream(c)\n        .observer\n        .takeWhile(p => this.deleted !== true);\n    };// getGlobalParam('streamsController').getStream(c).observer;\n\n    let fn = R.ifElse(isValidChannel, startSubscribe, error);\n\n    return fn(channel);\n  }\n\n  /**\n   *\n   * Preferred method to connect to instances of registered channels, such as 'DOM', 'UI', and 'ROUTE' channels.\n   *\n   * Add Channel will automatically unsubscribe to the channel, whereas the getChannel method requires the developer to manually unsubscribe.\n   *\n   * @param {string} str The name of the registered Channel that was added to the Channels Controller.\n   * @param {boolean} bool false, add true if the View should wait for this channel to unsubscribe before removing itself.\n   * @param {sendDownStream} bool The direction where the stream is allowed to travel.\n   *\n   * @example\n   *\n   * let routeChannel = this.addChannel('ROUTE');\n   *\n   *      addActionMethods() {\n     *           return [\n     *             ['CHANNEL_ROUTE_CHANGE_EVENT', 'onMapRouteEvent']\n     *           ]\n     *       }\n   *\n   *       onMapRouteEvent(p) {\n     *          console.log('the route value is ', p);\n     *       }\n   *\n   *\n   * */\n\n  addChannel(str, sendDownStream = false, bool = false) {\n    const directionArr = sendDownStream === true ? this.$dirs.CI : this.$dirs.I;\n    const mapDirection = p => Object.assign({$dir: directionArr}, R.clone(p));\n    let channel$ = this.getChannel(str).map(mapDirection);\n    this.updateSourceSubscription(channel$, false);\n  }\n\n  /**\n   * Method to send data to any registered channel.\n   * @param {string} channelName The name of the registered Channel that was added to the Channels Controller.\n   * @param {string} action The event type that listeners can point to.\n   * @param {object} payload {}, The main data to send to the channel.\n   * @example\n   * let payload = {'location' : 'about'};\n   * let action = 'PAGE_CHANGE_EVENT';\n   * this.sendChannelPayload('ROUTE', paylaod, action);\n   *\n   * */\n\n  sendChannelPayload(channelName, action = 'DEFAULT_EVENT', payload = {}) {\n    let cid = this.props.cid;\n    let viewName = this.props.name;\n    let data = {cid, viewName, payload, action};\n    let obs$ = Rx.Observable.of(data);\n    return new _channels_channels_payload__WEBPACK_IMPORTED_MODULE_7__[\"ChannelsPayload\"](channelName, obs$, data);\n  }\n\n  tracer() {\n\n  }\n\n  isLocalEvent(channelStreamItem) {\n    const itemEl = R.path(['srcElement', 'el'], channelStreamItem);\n    return itemEl !== undefined &&\n        this.props.el.contains(channelStreamItem.srcElement.el);\n  }\n\n  //  =======================================================================================\n  addMixins() {\n    //  ==================================\n    // BASE CORE MIXINS\n    //  ==================================\n    let coreMixins = Object(_utils_mixins_base_core_mixins__WEBPACK_IMPORTED_MODULE_0__[\"baseCoreMixins\"])();\n    this.createId = coreMixins.createId;\n    this.createpropsMap = coreMixins.createpropsMap;\n    this.convertDomStringMapToObj = _utils_frp_tools__WEBPACK_IMPORTED_MODULE_2__[\"convertDomStringMapToObj\"];\n    this.ifNilThenUpdate = _utils_frp_tools__WEBPACK_IMPORTED_MODULE_2__[\"ifNilThenUpdate\"];\n    // this.gc = gc.bind(this);\n    //  ==================================\n    // BASE STREAM MIXINS\n    //  ==================================\n    let streamMixins = Object(_utils_mixins_base_streams_mixins__WEBPACK_IMPORTED_MODULE_1__[\"baseStreamsMixins\"])();\n    this.sendUIPayload = streamMixins.sendUIPayload;\n    this.sendRoutePayload = streamMixins.sendRoutePayload;\n    this.sendChannelPayload = streamMixins.sendChannelPayload.bind(this);\n    this.createLifeStreamPayload = streamMixins.createLifeStreamPayload;\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/views/view-stream.js?");

/***/ }),

/***/ "./src/spyne/views/view-to-dom-mediator.js":
/*!*************************************************!*\
  !*** ./src/spyne/views/view-to-dom-mediator.js ***!
  \*************************************************/
/*! exports provided: ViewToDomMediator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewToDomMediator\", function() { return ViewToDomMediator; });\n/* harmony import */ var _utils_mixins_base_core_mixins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mixins/base-core-mixins */ \"./src/spyne/utils/mixins/base-core-mixins.js\");\n/* harmony import */ var _dom_item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-item */ \"./src/spyne/views/dom-item.js\");\n/* harmony import */ var _utils_frp_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/frp-tools */ \"./src/spyne/utils/frp-tools.js\");\n/* harmony import */ var _utils_viewstream_animations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/viewstream-animations */ \"./src/spyne/utils/viewstream-animations.js\");\n/* harmony import */ var _utils_viewstream_lifecycle_observables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/viewstream-lifecycle-observables */ \"./src/spyne/utils/viewstream-lifecycle-observables.js\");\n\n\n\n\n\n\nconst Rx = __webpack_require__(/*! rxjs */ \"rxjs\");\nconst R = __webpack_require__(/*! ramda */ \"ramda\");\n\nclass ViewToDomMediator {\n  constructor(sink$, viewProps = {}, cid = '', vsName = 'theName') {\n    this.addMixins();\n    this._state = 'INIT';\n    this.cid = cid;\n    this.vsName = vsName;\n    this.defaults = {\n      debug:false,\n      extendedHashMethods: {}\n    };\n    this.options = Object.assign({}, this.defaults, viewProps);\n    let createExtraStatesMethod = (arr) => {\n      let [action, funcStr] = arr;\n      this.options.extendedHashMethods[action] = (p) => this[funcStr](p);\n    };\n    this.addActionMethods().forEach(createExtraStatesMethod);\n    this.options.hashMethods = this.setHashMethods(this.options.extendedHashMethods);\n    this.sink$ = sink$;\n    this.sink$\n      .subscribe(this.onSinkSubscribe.bind(this));\n\n    this.$dirs = _utils_viewstream_lifecycle_observables__WEBPACK_IMPORTED_MODULE_4__[\"LifecyleObservables\"].createDirectionalFiltersObject();\n    this.addDefaultDir = _utils_viewstream_lifecycle_observables__WEBPACK_IMPORTED_MODULE_4__[\"LifecyleObservables\"].addDefaultDir;\n    this.sourceStreams = _utils_viewstream_lifecycle_observables__WEBPACK_IMPORTED_MODULE_4__[\"LifecyleObservables\"].createDirectionalObservables();\n    this._source$ = this.sourceStreams.toInternal$; //  new Rx.Subject();\n  }\n  addActionMethods() {\n    return [];\n  }\n  setHashMethods(extendedHashMethodsObj = {}) {\n    let defaultHashMethods = {\n      'GARBAGE_COLLECT'                : (p) => this.onGarbageCollect(p),\n      'READY_FOR_GC'                   : (p) => this.onReadyForGC(p),\n      'DISPOSE'                        : (p) => this.onDispose(p),\n      'RENDER'                         : (p) => this.onRender(p),\n      'RENDER_AND_ATTACH_TO_PARENT'    : (p) => this.onRenderAndAttachToParent(p),\n      'RENDER_AND_ATTACH_TO_DOM'       : (p) => this.onRenderAndAttachToDom(p),\n      'ATTACH_CHILD_TO_SELF'           : (p) => this.onAttachChildToSelf(p)\n    };\n    return Object.assign({}, defaultHashMethods, extendedHashMethodsObj);\n  }\n\n  createDomItem() {\n    this.props = this.props !== undefined ? this.props : {};\n    let removeIsNil = (val) => val !== undefined;\n    let attrs = R.filter(removeIsNil, R.pick(['id', 'className'], this.props));\n    return new _dom_item__WEBPACK_IMPORTED_MODULE_1__[\"DomItem\"](this.props.tagName, attrs, this.props.data, this.props.template);\n  }\n\n  onDisposeCompleted(d) {\n    // console.log('bv self disposed after animateOut ', d, this);\n  }\n\n  animateInTween(el, time) {\n    Object(_utils_viewstream_animations__WEBPACK_IMPORTED_MODULE_3__[\"fadein\"])(el, time);\n  }\n\n  animateOutTween(el, time, callback) {\n    // console.log('anim out ', {el, time, callback});\n    Object(_utils_viewstream_animations__WEBPACK_IMPORTED_MODULE_3__[\"fadeout\"])(el, time, callback);\n  }\n\n  setAnimateIn(d) {\n    if (d.animateIn === true) {\n      let el = d.el !== undefined ? d.el : this.domItem.el;\n      this.animateInTween(el, d.animateOutTime);\n    }\n  }\n\n  disposeMethodOld(d) {\n    let animateOut = (d, callback) => {\n      let el = d.el.el !== undefined ? d.el.el : d.el; // DOM ITEMS HAVE THEIR EL ITEMS NESTED\n      this.animateOutTween(el, d.animateOutTime, callback);\n    };\n\n    let fadeOutObs = Rx.Observable.bindCallback(animateOut);\n    let onFadeoutCompleted = (e) => {\n      // console.log('fade out completed ', e, d);\n      this._source$.next({action:'READY_FOR_GC', $dir:this.$dirs.I});\n    };\n\n    let onFadeoutObs = (d) => {\n      fadeOutObs(d)\n        .subscribe(onFadeoutCompleted);\n      return {action:'DISPOSING', $dir:this.$dirs.CI};\n    };\n    let onEmptyObs = () => ({action:'DISPOSE_AND_READY_FOR_GC', $dir:this.$dirs.PCI});\n    let fn = d.animateOut === true ? onFadeoutObs : onEmptyObs;\n    return fn(d);\n  }\n\n  disposeMethod(d) {\n    let onFadeoutObs = () => {\n      let el = d.el.el !== undefined ? d.el.el : d.el; // DOM ITEMS HAVE THEIR EL ITEMS NESTED\n      const gcData = {action:'READY_FOR_GC', $dir:this.$dirs.PI, el};\n\n      d.el$.setClass(d.animateOutClass);\n      // console.log('DISPOSE FADE OUT ', el, this.$dirs, d.animateOutClass);\n\n      const subscriber = () => {\n        // console.log('MEDIATOR FADEOUT COMPLETE ', this.cid, gcData, this.animateOutClass, d);\n        this._source$.next(gcData);\n      };\n\n      Rx.Observable.fromEvent(el, 'transitionend')\n        .filter(e => e.target === el)\n        .take(1)\n        .subscribe(subscriber);\n    };\n    let onEmptyObs = () => ({action:'DISPOSE_AND_READY_FOR_GC', $dir:this.$dirs.PCI});\n    if (d.animateOutClass !== undefined) {\n      onFadeoutObs();\n      return {action:'DISPOSING', $dir:this.$dirs.CI};\n    } else {\n      return onEmptyObs();\n    }\n  }\n\n  onDispose(d) {\n    return this.disposeMethod(d);\n  }\n\n  removeStream() {\n    // this.sourceStreams.completeAll();\n    if (this.sourceStreams !== undefined) {\n      this.sourceStreams.completeStream(['internal', 'child']);\n    }\n    // this._source$.complete();\n    // this._source$.isStopped = true;\n  }\n\n  onGarbageCollect9(p) {\n    // console.log('MEDIATOR onGarbageCollect ', this.cid, this.vsName, p);\n    const t = this.vsName === 'PageChildBox' ? 1000 : 0;\n    window.setTimeout(this.onGarbageCollectRun.bind(this), t);\n  }\n\n  onReadyForGC(p) {\n    this.removeStream();\n  }\n\n  onGarbageCollect(p) {\n    // console.log('MEDIATOR onGarbageCollect ', this.cid, this.vsName, p);\n    if (this.sourceStreams !== undefined) {\n      this.sourceStreams.completeStream(['parent']);\n    }\n\n    this.domItem.unmount();\n    delete this;\n  }\n\n  getSourceStream() {\n    return this._source$;\n  }\n\n  combineDomItems(d) {\n    let container =  R.isNil(d.query) ? d.node : d.query;\n    let prepend = (node, item) => node.insertBefore(item, node.firstChild);\n    let append = (node, item) => node.appendChild(item);\n    // DETERMINE WHETHER TO USE APPEND OR PREPEND\n    // ON CONNECTING DOM ITEMS TO EACH OTHER\n    // this.domItemEl = this.domItem.render();\n    let attachFunc = d.attachType === 'appendChild' ? append : prepend;\n    // d.node = R.isNil(d.query) ? d.node : d.query;\n    attachFunc(container, this.domItem.render());\n    this.setAnimateIn(d);\n  }\n\n  onAttachChildToSelf(p) {\n    let data = p.childRenderData;\n    this.combineDomItems(data);\n    return {\n      action: 'CHILD_ATTACHED',\n      $dir: this.$dirs.PI\n    };\n  }\n\n  onRenderAndAttachToParent(d) {\n    this.onRender(d);\n    this.combineDomItems(d);\n    return {\n      action: 'RENDERED_AND_ATTACHED_TO_PARENT',\n      el: this.domItem.el,\n      $dir: this.$dirs.PI\n    };\n  }\n\n  renderDomItem(d) {\n    this.domItem = new _dom_item__WEBPACK_IMPORTED_MODULE_1__[\"DomItem\"](...d);\n    return this.domItem;\n  }\n\n  onRender(d) {\n    let getEl = (data) => this.renderDomItem(data);\n    let el =  getEl(R.props(['tagName', 'domAttributes', 'data', 'template'], d));\n    return {\n      action: 'RENDERED',\n      el,\n      $dir: this.$dirs.I\n    };\n  }\n\n  extendedMethods(data) {\n  }\n\n  onRenderAndAttachToDom(d) {\n    let getEl = (data) => this.renderDomItem(data);\n    // let getEl = (data) => new DomItem(...data);\n    d.attachData['el'] = getEl(R.props(['tagName', 'domAttributes', 'data', 'template'], d));\n    this.combineDomItems(d.attachData);\n    return {\n      action: 'RENDERED_AND_ATTACHED_TO_DOM',\n      el:     d.attachData['el'].el,\n      $dir: this.$dirs.CI\n    };\n  }\n\n  onSinkSubscribe(payload) {\n    let action = payload.action;\n    let defaultToFn = R.defaultTo((data) => this.extendedMethods(data));\n    let fn = defaultToFn(this.options.hashMethods[action]);\n    // console.log('MEDIATOR onSinkSubscribe before ', this.cid, action, payload);\n    let data = fn(payload);\n    // data = this.addDefaultDir(data);\n    // console.log('add default dir ', data);\n    let sendData = (d) => this._source$.next(d);\n    if (data !== undefined) {\n      // console.log('MEDIATOR onSinkSubscribe ', this.cid, data, payload);\n      sendData(Object.freeze(data));\n    }\n  }\n\n  addMixins() {\n    //  ==================================\n    // BASE CORE MIXINS\n    //  ==================================\n    let coreMixins = Object(_utils_mixins_base_core_mixins__WEBPACK_IMPORTED_MODULE_0__[\"baseCoreMixins\"])();\n    this.createId = coreMixins.createId;\n    this.createpropsMap = coreMixins.createpropsMap;\n    this.convertDomStringMapToObj = _utils_frp_tools__WEBPACK_IMPORTED_MODULE_2__[\"convertDomStringMapToObj\"];\n    this.ifNilThenUpdate = _utils_frp_tools__WEBPACK_IMPORTED_MODULE_2__[\"ifNilThenUpdate\"];\n  }\n}\n\n\n//# sourceURL=webpack://spyne/./src/spyne/views/view-to-dom-mediator.js?");

/***/ }),

/***/ "ramda":
/*!**********************************************************************************!*\
  !*** external {"commonjs":"ramda","commonjs2":"ramda","amd":"ramda","root":"R"} ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_ramda__;\n\n//# sourceURL=webpack://spyne/external_%7B%22commonjs%22:%22ramda%22,%22commonjs2%22:%22ramda%22,%22amd%22:%22ramda%22,%22root%22:%22R%22%7D?");

/***/ }),

/***/ "rxjs":
/*!********************************************************************************!*\
  !*** external {"commonjs":"rxjs","commonjs2":"rxjs","amd":"rxjs","root":"Rx"} ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_rxjs__;\n\n//# sourceURL=webpack://spyne/external_%7B%22commonjs%22:%22rxjs%22,%22commonjs2%22:%22rxjs%22,%22amd%22:%22rxjs%22,%22root%22:%22Rx%22%7D?");

/***/ })

/******/ });
});